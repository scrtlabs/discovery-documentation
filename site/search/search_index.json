{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Enigma? \ud83e\udd14 Enigma is a decentralized network that enables Secret Contracts . This means you can create decentralized applications with end-to-end data privacy and strong correctness guarantees. Data inputs, and outputs are encrypted throughout. Even the nodes running the computation can't see the data . Enigma is Ethereum compatible . Secret Contracts can call any function inside a smart contract on Ethereum. Ready to dive in? Get started quickly with our Quick Start guide Build your first secret contract Check out some ideas for what to build with Enigma Data Flow \ud83d\udcbe A secret contract function call is considered a single private computation or task . Secret contracts are registered at deployment on the Enigma Contract (on Ethereum), which the Enigma network watches for new tasks. These tasks are initiated (and paid for) by the end users of Ethereum dApps and are then offloaded from Ethereum into the Enigma network for computation. The Enigma network then selects a worker node to execute the given task in a modified Web Assembly interpreter (WASMI) running inside a Trusted Execution Environment (TEE) using Intel Software Guard Extensions (SGX) technology (also known as an enclave ). After computing a task, a cryptographic proof of the completed task is recorded, and eventually verified, on the Ethereum network. Enigma and Ethereum Enigma and Ethereum work together, and separate computation and storage from consensus. Enigma: Compute and Storage Layer Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys. Ethereum: Consensus Layer Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status. Key Concepts \ud83e\udd1e Secret Contract Task Enigma Contract Enigma JS Library Worker Node What can I do with Enigma? \ud83d\udee0\ufe0f The Discovery release of Enigma has plenty of exciting new features, including secret state , Rust-based secret contracts, private outputs, and more. Some of the applications we're excited about include: Access-control for data (like price predictions or a pointer to an IPFS file) Games where your \"pocket cards\" must stay secret (like Gin Rummy or Poker) Private voting, without a commit-reveal scheme (actually, any use-case with a commit-reveal pattern can be streamlined with Enigma!) Secret inputs to a credit-scoring algorithm Sybil-prevention via social verification -- without exposing your user's data!","title":"About Enigma"},{"location":"#what-is-enigma","text":"Enigma is a decentralized network that enables Secret Contracts . This means you can create decentralized applications with end-to-end data privacy and strong correctness guarantees. Data inputs, and outputs are encrypted throughout. Even the nodes running the computation can't see the data . Enigma is Ethereum compatible . Secret Contracts can call any function inside a smart contract on Ethereum. Ready to dive in? Get started quickly with our Quick Start guide Build your first secret contract Check out some ideas for what to build with Enigma","title":"What is Enigma? \ud83e\udd14"},{"location":"#data-flow","text":"A secret contract function call is considered a single private computation or task . Secret contracts are registered at deployment on the Enigma Contract (on Ethereum), which the Enigma network watches for new tasks. These tasks are initiated (and paid for) by the end users of Ethereum dApps and are then offloaded from Ethereum into the Enigma network for computation. The Enigma network then selects a worker node to execute the given task in a modified Web Assembly interpreter (WASMI) running inside a Trusted Execution Environment (TEE) using Intel Software Guard Extensions (SGX) technology (also known as an enclave ). After computing a task, a cryptographic proof of the completed task is recorded, and eventually verified, on the Ethereum network.","title":"Data Flow \ud83d\udcbe"},{"location":"#enigma-and-ethereum","text":"Enigma and Ethereum work together, and separate computation and storage from consensus.","title":"Enigma and Ethereum"},{"location":"#enigma-compute-and-storage-layer","text":"Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys.","title":"Enigma: Compute and Storage Layer"},{"location":"#ethereum-consensus-layer","text":"Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status. Key Concepts \ud83e\udd1e Secret Contract Task Enigma Contract Enigma JS Library Worker Node","title":"Ethereum: Consensus Layer"},{"location":"#what-can-i-do-with-enigma","text":"The Discovery release of Enigma has plenty of exciting new features, including secret state , Rust-based secret contracts, private outputs, and more. Some of the applications we're excited about include: Access-control for data (like price predictions or a pointer to an IPFS file) Games where your \"pocket cards\" must stay secret (like Gin Rummy or Poker) Private voting, without a commit-reveal scheme (actually, any use-case with a commit-reveal pattern can be streamlined with Enigma!) Secret inputs to a credit-scoring algorithm Sybil-prevention via social verification -- without exposing your user's data!","title":"What can I do with Enigma? \ud83d\udee0\ufe0f"},{"location":"API/","text":"Functions admin() Initialize the worker-specific admin features createContracts(enigmaContractAddr, tokenContractAddr) Initialize the Enigma and Enigma token contracts createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task Create a base Task - a wrapper for a task (either contract deployments or regular tasks) createTaskRecord(task) \u21d2 EventEmitter Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. createTaskRecords(tasks) \u21d2 EventEmitter Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. getTaskRecordStatus(task) \u21d2 Promise Get the Task s task record status from Ethereum getTaskOutputHash(task) \u21d2 Promise Fetch output hash at specified index position getReport(custodian) \u21d2 Promise Find SGX report getWorkerParams(blockNumber) \u21d2 Promise Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array Select the workers weighted-randomly based on the staked token amount that will run the computation task sendTaskInput(task) \u21d2 EventEmitter Send Task to Enigma p2p network for computation getTaskResult(task) \u21d2 EventEmitter Get task result from p2p network decryptTaskResult(task) \u21d2 Task Decrypt task result pollTaskStatusGen(task, withResult) Generator function for polling the Enigma p2p network for task status innerPollTaskStatus(task, generator, emitter) Inner poll status function that continues to poll the Enigma p2p network until the task has been verified pollTaskStatus(task, withResult) \u21d2 EventEmitter Poll the Enigma p2p network for a TaskInput s status serializeTask(task) \u21d2 Object Serialize Task for submission to the Enigma p2p network obtainTaskKeyPair() \u21d2 Object Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task Create a compute task - creates base task, creates task record, and sends task to the Enigma network. version() \u21d2 string Return the version number of the library admin() Initialize the worker-specific admin features Kind : global function createContracts(enigmaContractAddr, tokenContractAddr) Initialize the Enigma and Enigma token contracts Kind : global function Param Type enigmaContractAddr string tokenContractAddr string createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task Create a base Task - a wrapper for a task (either contract deployments or regular tasks) Kind : global function Returns : Task - Task with base attributes to be used for remainder of task lifecycle Param Type Description fn string Function name args Array Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] gasLimit Number ENG gas limit for task computation gasPx Number ENG gas price for task computation sender string ETH address for task sender scAddrOrPreCode string Either secret contract address or precode, depending on if user is running a contract deployment or regular task isContractDeploymentTask boolean Is this task a contract deployment task (if not, it's a regular task) createTaskRecord(task) \u21d2 EventEmitter Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task record. Emits a Task with task record creation attributes to be used for remainder of task lifecycle Param Type Description task Task Task wrapper for contract deployment and regular tasks createTaskRecords(tasks) \u21d2 EventEmitter Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task records. Emits Tasks with task record creation attributes to be used for remainder of task lifecycle Param Type Description tasks Array Task wrappers for contract deployment and regular tasks getTaskRecordStatus(task) \u21d2 Promise Get the Task's task record status from Ethereum Kind : global function Returns : Promise - Resolves to Task wrapper with updated ethStatus and proof properties Param Type Description task Task Task wrapper for contract deployment and regular tasks getTaskOutputHash(task) \u21d2 Promise Fetch output hash at specified index position Kind : global function Returns : Promise - - Resolves to output hash at the specified position Param Type Description task Task Task wrapper getReport(custodian) \u21d2 Promise Find SGX report Kind : global function Returns : Promise - Resolves to SGX report for the worker Param Type Description custodian string Worker's address getWorkerParams(blockNumber) \u21d2 Promise Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. Kind : global function Returns : Promise - Resolves to the worker params, which includes a seed (random int generated from the principal node), first block number for the epoch, list of active work addresses (ordered list of workers that were logged in at the start of the epoch), and list of active worker balances Param Type Description blockNumber int Block number of task record's mining selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array Select the workers weighted-randomly based on the staked token amount that will run the computation task Kind : global function Returns : Array - An array of selected workers where each selected worker is chosen with probability equal to number of staked tokens Param Type Default Description scAddr string Secret contract address params Object Worker params: 1) Worker addresses; 2) Worker stakes; 3) Network seed workerGroupSize number 5 Number of workers to be selected for task sendTaskInput(task) \u21d2 EventEmitter Send Task to Enigma p2p network for computation Kind : global function Returns : EventEmitter - EventEmitter to be listened to track submission of Task to Enigma p2p network. Emits a response from the ENG network indicating whether client is ready to track the remainder of the task lifecycle Param Type Description task Task Task wrapper for contract deployment and regular tasks getTaskResult(task) \u21d2 EventEmitter Get task result from p2p network Kind : global function Returns : EventEmitter - EventEmitter to be listened to track getting result from Enigma network. Emits a response from the ENG network. Param Type Description task Task Task wrapper for contract deployment and regular tasks decryptTaskResult(task) \u21d2 Task Decrypt task result Kind : global function Returns : Task - Decrypted task result wrapper Param Type Description task Task Task wrapper for contract deployment and regular tasks pollTaskStatusGen(task, withResult) Generator function for polling the Enigma p2p network for task status Kind : global function Param Type Description task Task Task wrapper for contract deployment and regular tasks withResult boolean Task wrapper for contract deployment and regular tasks innerPollTaskStatus(task, generator, emitter) Inner poll status function that continues to poll the Enigma p2p network until the task has been verified Kind : global function Param Type Description task Task Task wrapper for contract deployment and regular tasks generator pollTaskStatusGen Generator function for polling Enigma p2p network for task status emitter EventEmitter EventEmitter to track Enigma p2p network polling for Task status pollTaskStatus(task, withResult) \u21d2 EventEmitter Poll the Enigma p2p network for a TaskInput's status Kind : global function Returns : EventEmitter - EventEmitter to be listened to track polling the Enigma p2p network for a Task status. Emits a Task with task result attributes Param Type Default Description task Task Task wrapper for contract deployment and regular tasks withResult boolean false Task wrapper for contract deployment and regular tasks serializeTask(task) \u21d2 Object Serialize Task for submission to the Enigma p2p network Kind : global function Returns : Object - Serialized Task for submission to the Enigma p2p network Param Type Description task Task Task wrapper for contract deployment and regular tasks obtainTaskKeyPair() \u21d2 Object Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. Kind : global function Returns : Object - Public key-private key pair deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network Param Type Description fn string Function name args Array Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] gasLimit Number ENG gas limit for task computation gasPx Number ENG gas price for task computation sender string ETH address for task sender preCode string Precode for contract deployment computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task Create a compute task - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network Param Type Description fn string Function name args Array Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] gasLimit Number ENG gas limit for task computation gasPx Number ENG gas price for task computation sender string ETH address for task sender scAddr string Secret contract address version() \u21d2 string Return the version number of the library Kind : global function","title":"API"},{"location":"API/#functions","text":"admin() Initialize the worker-specific admin features createContracts(enigmaContractAddr, tokenContractAddr) Initialize the Enigma and Enigma token contracts createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task Create a base Task - a wrapper for a task (either contract deployments or regular tasks) createTaskRecord(task) \u21d2 EventEmitter Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. createTaskRecords(tasks) \u21d2 EventEmitter Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. getTaskRecordStatus(task) \u21d2 Promise Get the Task s task record status from Ethereum getTaskOutputHash(task) \u21d2 Promise Fetch output hash at specified index position getReport(custodian) \u21d2 Promise Find SGX report getWorkerParams(blockNumber) \u21d2 Promise Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array Select the workers weighted-randomly based on the staked token amount that will run the computation task sendTaskInput(task) \u21d2 EventEmitter Send Task to Enigma p2p network for computation getTaskResult(task) \u21d2 EventEmitter Get task result from p2p network decryptTaskResult(task) \u21d2 Task Decrypt task result pollTaskStatusGen(task, withResult) Generator function for polling the Enigma p2p network for task status innerPollTaskStatus(task, generator, emitter) Inner poll status function that continues to poll the Enigma p2p network until the task has been verified pollTaskStatus(task, withResult) \u21d2 EventEmitter Poll the Enigma p2p network for a TaskInput s status serializeTask(task) \u21d2 Object Serialize Task for submission to the Enigma p2p network obtainTaskKeyPair() \u21d2 Object Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task Create a compute task - creates base task, creates task record, and sends task to the Enigma network. version() \u21d2 string Return the version number of the library","title":"Functions"},{"location":"API/#admin","text":"Initialize the worker-specific admin features Kind : global function","title":"admin()"},{"location":"API/#createcontractsenigmacontractaddr-tokencontractaddr","text":"Initialize the Enigma and Enigma token contracts Kind : global function Param Type enigmaContractAddr string tokenContractAddr string","title":"createContracts(enigmaContractAddr, tokenContractAddr)"},{"location":"API/#createtaskfn-args-gaslimit-gaspx-sender-scaddrorprecode-iscontractdeploymenttask-task","text":"Create a base Task - a wrapper for a task (either contract deployments or regular tasks) Kind : global function Returns : Task - Task with base attributes to be used for remainder of task lifecycle Param Type Description fn string Function name args Array Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] gasLimit Number ENG gas limit for task computation gasPx Number ENG gas price for task computation sender string ETH address for task sender scAddrOrPreCode string Either secret contract address or precode, depending on if user is running a contract deployment or regular task isContractDeploymentTask boolean Is this task a contract deployment task (if not, it's a regular task)","title":"createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task"},{"location":"API/#createtaskrecordtask-eventemitter","text":"Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task record. Emits a Task with task record creation attributes to be used for remainder of task lifecycle Param Type Description task Task Task wrapper for contract deployment and regular tasks","title":"createTaskRecord(task) \u21d2 EventEmitter"},{"location":"API/#createtaskrecordstasks-eventemitter","text":"Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task records. Emits Tasks with task record creation attributes to be used for remainder of task lifecycle Param Type Description tasks Array Task wrappers for contract deployment and regular tasks","title":"createTaskRecords(tasks) \u21d2 EventEmitter"},{"location":"API/#gettaskrecordstatustask-promise","text":"Get the Task's task record status from Ethereum Kind : global function Returns : Promise - Resolves to Task wrapper with updated ethStatus and proof properties Param Type Description task Task Task wrapper for contract deployment and regular tasks","title":"getTaskRecordStatus(task) \u21d2 Promise"},{"location":"API/#gettaskoutputhashtask-promise","text":"Fetch output hash at specified index position Kind : global function Returns : Promise - - Resolves to output hash at the specified position Param Type Description task Task Task wrapper","title":"getTaskOutputHash(task) \u21d2 Promise"},{"location":"API/#getreportcustodian-promise","text":"Find SGX report Kind : global function Returns : Promise - Resolves to SGX report for the worker Param Type Description custodian string Worker's address","title":"getReport(custodian) \u21d2 Promise"},{"location":"API/#getworkerparamsblocknumber-promise","text":"Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. Kind : global function Returns : Promise - Resolves to the worker params, which includes a seed (random int generated from the principal node), first block number for the epoch, list of active work addresses (ordered list of workers that were logged in at the start of the epoch), and list of active worker balances Param Type Description blockNumber int Block number of task record's mining","title":"getWorkerParams(blockNumber) \u21d2 Promise"},{"location":"API/#selectworkergroupscaddr-params-workergroupsize-array","text":"Select the workers weighted-randomly based on the staked token amount that will run the computation task Kind : global function Returns : Array - An array of selected workers where each selected worker is chosen with probability equal to number of staked tokens Param Type Default Description scAddr string Secret contract address params Object Worker params: 1) Worker addresses; 2) Worker stakes; 3) Network seed workerGroupSize number 5 Number of workers to be selected for task","title":"selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array"},{"location":"API/#sendtaskinputtask-eventemitter","text":"Send Task to Enigma p2p network for computation Kind : global function Returns : EventEmitter - EventEmitter to be listened to track submission of Task to Enigma p2p network. Emits a response from the ENG network indicating whether client is ready to track the remainder of the task lifecycle Param Type Description task Task Task wrapper for contract deployment and regular tasks","title":"sendTaskInput(task) \u21d2 EventEmitter"},{"location":"API/#gettaskresulttask-eventemitter","text":"Get task result from p2p network Kind : global function Returns : EventEmitter - EventEmitter to be listened to track getting result from Enigma network. Emits a response from the ENG network. Param Type Description task Task Task wrapper for contract deployment and regular tasks","title":"getTaskResult(task) \u21d2 EventEmitter"},{"location":"API/#decrypttaskresulttask-task","text":"Decrypt task result Kind : global function Returns : Task - Decrypted task result wrapper Param Type Description task Task Task wrapper for contract deployment and regular tasks","title":"decryptTaskResult(task) \u21d2 Task"},{"location":"API/#polltaskstatusgentask-withresult","text":"Generator function for polling the Enigma p2p network for task status Kind : global function Param Type Description task Task Task wrapper for contract deployment and regular tasks withResult boolean Task wrapper for contract deployment and regular tasks","title":"pollTaskStatusGen(task, withResult)"},{"location":"API/#innerpolltaskstatustask-generator-emitter","text":"Inner poll status function that continues to poll the Enigma p2p network until the task has been verified Kind : global function Param Type Description task Task Task wrapper for contract deployment and regular tasks generator pollTaskStatusGen Generator function for polling Enigma p2p network for task status emitter EventEmitter EventEmitter to track Enigma p2p network polling for Task status","title":"innerPollTaskStatus(task, generator, emitter)"},{"location":"API/#polltaskstatustask-withresult-eventemitter","text":"Poll the Enigma p2p network for a TaskInput's status Kind : global function Returns : EventEmitter - EventEmitter to be listened to track polling the Enigma p2p network for a Task status. Emits a Task with task result attributes Param Type Default Description task Task Task wrapper for contract deployment and regular tasks withResult boolean false Task wrapper for contract deployment and regular tasks","title":"pollTaskStatus(task, withResult) \u21d2 EventEmitter"},{"location":"API/#serializetasktask-object","text":"Serialize Task for submission to the Enigma p2p network Kind : global function Returns : Object - Serialized Task for submission to the Enigma p2p network Param Type Description task Task Task wrapper for contract deployment and regular tasks","title":"serializeTask(task) \u21d2 Object"},{"location":"API/#obtaintaskkeypair-object","text":"Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. Kind : global function Returns : Object - Public key-private key pair","title":"obtainTaskKeyPair() \u21d2 Object"},{"location":"API/#deploysecretcontractfn-args-gaslimit-gaspx-sender-precode-task","text":"Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network Param Type Description fn string Function name args Array Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] gasLimit Number ENG gas limit for task computation gasPx Number ENG gas price for task computation sender string ETH address for task sender preCode string Precode for contract deployment","title":"deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task"},{"location":"API/#computetaskfn-args-gaslimit-gaspx-sender-scaddr-task","text":"Create a compute task - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network Param Type Description fn string Function name args Array Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] gasLimit Number ENG gas limit for task computation gasPx Number ENG gas price for task computation sender string ETH address for task sender scAddr string Secret contract address","title":"computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task"},{"location":"API/#version-string","text":"Return the version number of the library Kind : global function","title":"version() \u21d2 string"},{"location":"ApplicationDesign/","text":"Building With Secrets \ud83d\udd10 This section introduces several concepts we think are useful when working with secret contracts and the Enigma network. \ud83e\udd1eWe also highly recommend our developer forum for application-specific design questions. This section covers actions you may want to take such as: Reading Ethereum State Getting data from oracles Working with Metamask and managing user credentials Design Patterns for Secret Contracts like: a. Relayers b. Timekeeping Reading Ethereum State Getting data from oracles Metamask and Web3 Design Patterns for Secret Contracts","title":"Building With Secrets \ud83d\udd10"},{"location":"ApplicationDesign/#building-with-secrets","text":"This section introduces several concepts we think are useful when working with secret contracts and the Enigma network. \ud83e\udd1eWe also highly recommend our developer forum for application-specific design questions. This section covers actions you may want to take such as: Reading Ethereum State Getting data from oracles Working with Metamask and managing user credentials Design Patterns for Secret Contracts like: a. Relayers b. Timekeeping","title":"Building With Secrets \ud83d\udd10"},{"location":"ApplicationDesign/#reading-ethereum-state","text":"","title":"Reading Ethereum State"},{"location":"ApplicationDesign/#getting-data-from-oracles","text":"","title":"Getting data from oracles"},{"location":"ApplicationDesign/#metamask-and-web3","text":"","title":"Metamask and Web3"},{"location":"ApplicationDesign/#design-patterns-for-secret-contracts","text":"","title":"Design Patterns for Secret Contracts"},{"location":"DeploymentWalkthrough/","text":"Building the dApp \ud83c\udfac Adi's Enigma JS Library, deployment walkthrough","title":"Building the dApp \ud83c\udfac"},{"location":"DeploymentWalkthrough/#building-the-dapp","text":"Adi's Enigma JS Library, deployment walkthrough","title":"Building the dApp \ud83c\udfac"},{"location":"DeveloperMode/","text":"Developer Mode \ud83d\udcbb Developer mode (also known as Simulation mode) enables local deployment and testing of the Enigma Network as a series of Docker containers. This is the development mode we recommend for application developers writing secret contracts. While it is possible to deploy the network in \"hardware mode\", we recommend this for node runners.","title":"Developer Mode \ud83d\udcbb"},{"location":"DeveloperMode/#developer-mode","text":"Developer mode (also known as Simulation mode) enables local deployment and testing of the Enigma Network as a series of Docker containers. This is the development mode we recommend for application developers writing secret contracts. While it is possible to deploy the network in \"hardware mode\", we recommend this for node runners.","title":"Developer Mode \ud83d\udcbb"},{"location":"DiscoveryTestnet/","text":"Connecting to Discovery on Testnet \ud83c\udfd7\ufe0f Coming soon! \ud83d\udc77\u200d\u2640\ufe0f","title":"Connecting to Discovery on Testnet \ud83c\udfd7\ufe0f"},{"location":"DiscoveryTestnet/#connecting-to-discovery-on-testnet","text":"Coming soon! \ud83d\udc77\u200d\u2640\ufe0f","title":"Connecting to Discovery on Testnet \ud83c\udfd7\ufe0f"},{"location":"EnigmaArchitecture/","text":"Enigma Network Architecture \ud83e\udd1d Enigma and Ethereum work together, and separate computation and storage from consensus. Enigma: Compute and Storage Layer Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys. Ethereum: Consensus Layer Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status.","title":"Enigma Network Architecture \ud83e\udd1d"},{"location":"EnigmaArchitecture/#enigma-network-architecture","text":"Enigma and Ethereum work together, and separate computation and storage from consensus.","title":"Enigma Network Architecture \ud83e\udd1d"},{"location":"EnigmaArchitecture/#enigma-compute-and-storage-layer","text":"Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys.","title":"Enigma: Compute and Storage Layer"},{"location":"EnigmaArchitecture/#ethereum-consensus-layer","text":"Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status.","title":"Ethereum: Consensus Layer"},{"location":"EnigmaOverview/","text":"An Overview of Enigma \ud83d\udd0d The Enigma Network offloads private computation tasks from Ethereum. These tasks are initiated by the end users of Ethereum dApps. The Enigma protocol provides Enigma-JS, a JavaScript library that gives dApp developers the tools to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. A key distinction between the current Discovery release and the last release is that the Enigma Network has its own secret contracts. Instead of writing the business logic of a computation task in a function of an Ethereum smart contract, the dApp author creates a secret contract and deploys it on the Enigma Network. This is more powerful for many reasons; notably, a secret contract may store an encrypted state. The Enigma Library Computation tasks are created by dApp users using the Enigma Library. In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks. On-Chain Computation Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas. Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results. A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Unlike MVT, workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: the current epoch ends the business logic of a task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. Ethereum does not store the tasks results nor the encrypted state deltas, only hashes from which nodes can verify the integrity of their own data.","title":"Enigma Technical Overview"},{"location":"EnigmaOverview/#an-overview-of-enigma","text":"The Enigma Network offloads private computation tasks from Ethereum. These tasks are initiated by the end users of Ethereum dApps. The Enigma protocol provides Enigma-JS, a JavaScript library that gives dApp developers the tools to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. A key distinction between the current Discovery release and the last release is that the Enigma Network has its own secret contracts. Instead of writing the business logic of a computation task in a function of an Ethereum smart contract, the dApp author creates a secret contract and deploys it on the Enigma Network. This is more powerful for many reasons; notably, a secret contract may store an encrypted state.","title":"An Overview of Enigma \ud83d\udd0d"},{"location":"EnigmaOverview/#the-enigma-library","text":"Computation tasks are created by dApp users using the Enigma Library. In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks.","title":"The Enigma Library"},{"location":"EnigmaOverview/#on-chain-computation","text":"Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas. Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results. A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Unlike MVT, workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: the current epoch ends the business logic of a task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. Ethereum does not store the tasks results nor the encrypted state deltas, only hashes from which nodes can verify the integrity of their own data.","title":"On-Chain Computation"},{"location":"FAQ/","text":"Discovery FAQ Data What is the size limit for data input to a secret computation? Currently, the size limit is 1 MB. We expect this number to be larger very soon. Does encrypted data have to be passed through an Ethereum contract before it can be computed on? The Discovery release uses \"Task Records\" to track computation tasks on Ethereum. A Task Record is a hash of all the inputs to a secret contract. It takes up significantly less space than raw data would. These hashed Task Records are submitted to Ethereum at the same time as the encrypted Task data is submitted to Enigma. Can encrypted data be stored on the Enigma network? Yes, Secret Contracts are stateful in the Discovery release. Nodes How does Enigma protect against side-channel attacks like Foreshadow and Spectre? This is a class of attack deployed against Trusted Execution Environments. In addition to Intel's protections against these attacks, Enigma provides the following features: Randomly selected nodes: A worker is never guaranteed to be selected for a task, increasing the cost and decreasing the potential value of executing a side-channel attack. Enigma Attestation Process: Enigma has streamlined a version of the Intel Attestation service for nodes. Local consensus: nodes agree on the result of a computation, ensuring that a worker is not returning an incorrect result. (NOTE: this is not part of the initial Discovery Developer Release) How is data shared between nodes? Ethereum Will the Discovery release be on a public Ethereum testnet i.e., Rinkeby/Ropsten/Kovan? Yes, we will launch Discovery on a public testnet prior to mainnet launch. However, the developer testnet release is only deployed locally. Will we be able to swap tokens for ENG easily to facilitate payment? Supporting token abstraction is a high-priority goal, but is not included in the Discovery developer release. Secret Contracts Will Discovery contracts be forward-compatible Yes. Future iterations of the network will also support Rust-based contracts, and we are aiming for forward compatibility in all contracts. What languages are supported for secret contracts? Secret contracts are written using Rust. Oracles How do I get oracle data into a computation? We currently do not support TLS or HTTP requests within a computation. We suggest that developers utilize a relayer model where applicable to obtain and submit this type of data.","title":"FAQ"},{"location":"FAQ/#discovery-faq","text":"","title":"Discovery FAQ"},{"location":"FAQ/#data","text":"","title":"Data"},{"location":"FAQ/#what-is-the-size-limit-for-data-input-to-a-secret-computation","text":"Currently, the size limit is 1 MB. We expect this number to be larger very soon.","title":"What is the size limit for data input to a secret computation?"},{"location":"FAQ/#does-encrypted-data-have-to-be-passed-through-an-ethereum-contract-before-it-can-be-computed-on","text":"The Discovery release uses \"Task Records\" to track computation tasks on Ethereum. A Task Record is a hash of all the inputs to a secret contract. It takes up significantly less space than raw data would. These hashed Task Records are submitted to Ethereum at the same time as the encrypted Task data is submitted to Enigma.","title":"Does encrypted data have to be passed through an Ethereum contract before it can be computed on?"},{"location":"FAQ/#can-encrypted-data-be-stored-on-the-enigma-network","text":"Yes, Secret Contracts are stateful in the Discovery release.","title":"Can encrypted data be stored on the Enigma network?"},{"location":"FAQ/#nodes","text":"","title":"Nodes"},{"location":"FAQ/#how-does-enigma-protect-against-side-channel-attacks-like-foreshadow-and-spectre","text":"This is a class of attack deployed against Trusted Execution Environments. In addition to Intel's protections against these attacks, Enigma provides the following features: Randomly selected nodes: A worker is never guaranteed to be selected for a task, increasing the cost and decreasing the potential value of executing a side-channel attack. Enigma Attestation Process: Enigma has streamlined a version of the Intel Attestation service for nodes. Local consensus: nodes agree on the result of a computation, ensuring that a worker is not returning an incorrect result. (NOTE: this is not part of the initial Discovery Developer Release)","title":"How does Enigma protect against side-channel attacks like Foreshadow and Spectre?"},{"location":"FAQ/#how-is-data-shared-between-nodes","text":"","title":"How is data shared between nodes?"},{"location":"FAQ/#ethereum","text":"","title":"Ethereum"},{"location":"FAQ/#will-the-discovery-release-be-on-a-public-ethereum-testnet-ie-rinkebyropstenkovan","text":"Yes, we will launch Discovery on a public testnet prior to mainnet launch. However, the developer testnet release is only deployed locally.","title":"Will the Discovery release be on a public Ethereum testnet i.e., Rinkeby/Ropsten/Kovan?"},{"location":"FAQ/#will-we-be-able-to-swap-tokens-for-eng-easily-to-facilitate-payment","text":"Supporting token abstraction is a high-priority goal, but is not included in the Discovery developer release.","title":"Will we be able to swap tokens for ENG easily to facilitate payment?"},{"location":"FAQ/#secret-contracts","text":"","title":"Secret Contracts"},{"location":"FAQ/#will-discovery-contracts-be-forward-compatible","text":"Yes. Future iterations of the network will also support Rust-based contracts, and we are aiming for forward compatibility in all contracts.","title":"Will Discovery contracts be forward-compatible"},{"location":"FAQ/#what-languages-are-supported-for-secret-contracts","text":"Secret contracts are written using Rust.","title":"What languages are supported for secret contracts?"},{"location":"FAQ/#oracles","text":"","title":"Oracles"},{"location":"FAQ/#how-do-i-get-oracle-data-into-a-computation","text":"We currently do not support TLS or HTTP requests within a computation. We suggest that developers utilize a relayer model where applicable to obtain and submit this type of data.","title":"How do I get oracle data into a computation?"},{"location":"Fees/","text":"Computation Fees \ud83c\udfc6 Secret Contracts are executed by nodes in the Enigma Network. Nodes are incentivized to perform these computations with fees paid by the user initiating the computation.","title":"Computation Fees \ud83c\udfc6"},{"location":"Fees/#computation-fees","text":"Secret Contracts are executed by nodes in the Enigma Network. Nodes are incentivized to perform these computations with fees paid by the user initiating the computation.","title":"Computation Fees \ud83c\udfc6"},{"location":"GettingStarted/","text":"Check the documentation for how to use Docusaurus. Lorem Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus elementum massa eget nulla aliquet sagittis. Proin odio tortor, vulputate ut odio in, ultrices ultricies augue. Cras ornare ultrices lorem malesuada iaculis. Etiam sit amet libero tempor, pulvinar mauris sed, sollicitudin sapien. Mauris In Code Mauris vestibulum ullamcorper nibh, ut semper purus pulvinar ut. Donec volutpat orci sit amet mauris malesuada, non pulvinar augue aliquam. Vestibulum ultricies at urna ut suscipit. Morbi iaculis, erat at imperdiet semper, ipsum nulla sodales erat, eget tincidunt justo dui quis justo. Pellentesque dictum bibendum diam at aliquet. Sed pulvinar, dolor quis finibus ornare, eros odio facilisis erat, eu rhoncus nunc dui sed ex. Nunc gravida dui massa, sed ornare arcu tincidunt sit amet. Maecenas efficitur sapien neque, a laoreet libero feugiat ut. Nulla Nulla facilisi. Maecenas sodales nec purus eget posuere. Sed sapien quam, pretium a risus in, porttitor dapibus erat. Sed sit amet fringilla ipsum, eget iaculis augue. Integer sollicitudin tortor quis ultricies aliquam. Suspendisse fringilla nunc in tellus cursus, at placerat tellus scelerisque. Sed tempus elit a sollicitudin rhoncus. Nulla facilisi. Morbi nec dolor dolor. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Cras et aliquet lectus. Pellentesque sit amet eros nisi. Quisque ac sapien in sapien congue accumsan. Nullam in posuere ante. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Proin lacinia leo a nibh fringilla pharetra. Orci Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Proin venenatis lectus dui, vel ultrices ante bibendum hendrerit. Aenean egestas feugiat dui id hendrerit. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur in tellus laoreet, eleifend nunc id, viverra leo. Proin vulputate non dolor vel vulputate. Curabitur pretium lobortis felis, sit amet finibus lorem suscipit ut. Sed non mollis risus. Duis sagittis, mi in euismod tincidunt, nunc mauris vestibulum urna, at euismod est elit quis erat. Phasellus accumsan vitae neque eu placerat. In elementum arcu nec tellus imperdiet, eget maximus nulla sodales. Curabitur eu sapien eget nisl sodales fermentum. Phasellus Phasellus pulvinar ex id commodo imperdiet. Praesent odio nibh, sollicitudin sit amet faucibus id, placerat at metus. Donec vitae eros vitae tortor hendrerit finibus. Interdum et malesuada fames ac ante ipsum primis in faucibus. Quisque vitae purus dolor. Duis suscipit ac nulla et finibus. Phasellus ac sem sed dui dictum gravida. Phasellus eleifend vestibulum facilisis. Integer pharetra nec enim vitae mattis. Duis auctor, lectus quis condimentum bibendum, nunc dolor aliquam massa, id bibendum orci velit quis magna. Ut volutpat nulla nunc, sed interdum magna condimentum non. Sed urna metus, scelerisque vitae consectetur a, feugiat quis magna. Donec dignissim ornare nisl, eget tempor risus malesuada quis.","title":"Getting Started"},{"location":"GettingStarted/#lorem","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus elementum massa eget nulla aliquet sagittis. Proin odio tortor, vulputate ut odio in, ultrices ultricies augue. Cras ornare ultrices lorem malesuada iaculis. Etiam sit amet libero tempor, pulvinar mauris sed, sollicitudin sapien.","title":"Lorem"},{"location":"GettingStarted/#mauris-in-code","text":"Mauris vestibulum ullamcorper nibh, ut semper purus pulvinar ut. Donec volutpat orci sit amet mauris malesuada, non pulvinar augue aliquam. Vestibulum ultricies at urna ut suscipit. Morbi iaculis, erat at imperdiet semper, ipsum nulla sodales erat, eget tincidunt justo dui quis justo. Pellentesque dictum bibendum diam at aliquet. Sed pulvinar, dolor quis finibus ornare, eros odio facilisis erat, eu rhoncus nunc dui sed ex. Nunc gravida dui massa, sed ornare arcu tincidunt sit amet. Maecenas efficitur sapien neque, a laoreet libero feugiat ut.","title":"Mauris In Code"},{"location":"GettingStarted/#nulla","text":"Nulla facilisi. Maecenas sodales nec purus eget posuere. Sed sapien quam, pretium a risus in, porttitor dapibus erat. Sed sit amet fringilla ipsum, eget iaculis augue. Integer sollicitudin tortor quis ultricies aliquam. Suspendisse fringilla nunc in tellus cursus, at placerat tellus scelerisque. Sed tempus elit a sollicitudin rhoncus. Nulla facilisi. Morbi nec dolor dolor. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Cras et aliquet lectus. Pellentesque sit amet eros nisi. Quisque ac sapien in sapien congue accumsan. Nullam in posuere ante. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Proin lacinia leo a nibh fringilla pharetra.","title":"Nulla"},{"location":"GettingStarted/#orci","text":"Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Proin venenatis lectus dui, vel ultrices ante bibendum hendrerit. Aenean egestas feugiat dui id hendrerit. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur in tellus laoreet, eleifend nunc id, viverra leo. Proin vulputate non dolor vel vulputate. Curabitur pretium lobortis felis, sit amet finibus lorem suscipit ut. Sed non mollis risus. Duis sagittis, mi in euismod tincidunt, nunc mauris vestibulum urna, at euismod est elit quis erat. Phasellus accumsan vitae neque eu placerat. In elementum arcu nec tellus imperdiet, eget maximus nulla sodales. Curabitur eu sapien eget nisl sodales fermentum.","title":"Orci"},{"location":"GettingStarted/#phasellus","text":"Phasellus pulvinar ex id commodo imperdiet. Praesent odio nibh, sollicitudin sit amet faucibus id, placerat at metus. Donec vitae eros vitae tortor hendrerit finibus. Interdum et malesuada fames ac ante ipsum primis in faucibus. Quisque vitae purus dolor. Duis suscipit ac nulla et finibus. Phasellus ac sem sed dui dictum gravida. Phasellus eleifend vestibulum facilisis. Integer pharetra nec enim vitae mattis. Duis auctor, lectus quis condimentum bibendum, nunc dolor aliquam massa, id bibendum orci velit quis magna. Ut volutpat nulla nunc, sed interdum magna condimentum non. Sed urna metus, scelerisque vitae consectetur a, feugiat quis magna. Donec dignissim ornare nisl, eget tempor risus malesuada quis.","title":"Phasellus"},{"location":"Glossary/","text":"Attestation A process by which a piece of software can prove that is running in a secure container ( enclave ) on trusted hardware. This proof is a cryptographic signature, that certifies the hash of the secure container\u2019s contents. Attestation can be local , if two enclaves communicate with each other on the same host, or remote if it is attesting to a remote entity that it is trusted, and thus establishing an authenticated communication channel with that entity. Batch A set of tasks within an epoch that do not modify the state in the Ethereum network. dApp User An end=user of the Enigma network, responsible for initiating a task on the network. These users must: Have an Ethereum account Interface with the Enigma network through the Enigma JS Library Enclave An enclave is a private region of memory protected from processes running at higher privilege levels. Enclaves are only found in specific hardware that implements Trusted Execution Environments (TEE), like Intel Software Guard Extensions (SGX). An enclave is a critical component of a worker node. Any Secret Node must meet these hardware requirements. Epoch A unit of time in the Enigma network in which a worker node is assigned to work on a set of secret contracts does not change, and in which the state encryption keys do not change. Guarded (Code): Code that runs inside an enclave , and executes with privacy and correctness guarantees. Guarded code typically has an unguarded counterpart. Secret Contract Secret contracts are smart contracts that provide confidentiality guarantees. The contract functions are executed over encrypted inputs and outputs. Whereas smart contracts are defined as self-executing contracts with the terms of the agreement between parties being directly written into lines of code , secret contracts add privacy to the data submitted to these contracts. While the code of secret contracts remains public and auditable, the inputs and outputs to the contract are encrypted and hidden from public view. Secret contracts thus provide data privacy and verifiable computation. Secret contracts exist across a distributed, decentralized blockchain network ( Enigma ) and permit trusted and privacy-preserving transactions and agreements to be carried out among disparate, anonymous parties without the need for a central authority, legal system, or external enforcement mechanism. Task A single computation, also defined as a secret contract function call. Task Receipt A publicly verifiable proof that a task has been computed by an uncompromised enclave with all intended inputs. Task Record The record of a task stored on the Ethereum network for the purposes of: Ordering Fee Payment Token deposits (for payable functions) Unguarded (Code): Code that executes outside of an enclave , providing an interface between the code that runs inside the enclave ( guarded ) and the outside world. Unguarded code does not provide neither correctness nor privacy guarantees. User Node Node from the Enigma network through which a dApp user interfaces with the network. The user node brokers data flows between the dApp user, the worker node and other network participants using the peer-to-peer network protocol. dApp users can freely choose their user nodes through which they interact with the network. It may happen that the user node becomes the worker node for a given taks, but only if it happened to be randomly selected by the network. Worker or Worker Node Secret Node of the Enigma network selected to execute a task inside an enclave , characterized as follows: A task is only assigned one worker insofar as the worker meets the task\u2019s service level agreement A contract is only assigned one worker per epoch insofar as the worker successfully executes the tasks assigned.","title":"Glossary"},{"location":"Glossary/#attestation","text":"A process by which a piece of software can prove that is running in a secure container ( enclave ) on trusted hardware. This proof is a cryptographic signature, that certifies the hash of the secure container\u2019s contents. Attestation can be local , if two enclaves communicate with each other on the same host, or remote if it is attesting to a remote entity that it is trusted, and thus establishing an authenticated communication channel with that entity.","title":"Attestation"},{"location":"Glossary/#batch","text":"A set of tasks within an epoch that do not modify the state in the Ethereum network.","title":"Batch"},{"location":"Glossary/#dapp-user","text":"An end=user of the Enigma network, responsible for initiating a task on the network. These users must: Have an Ethereum account Interface with the Enigma network through the Enigma JS Library","title":"dApp User"},{"location":"Glossary/#enclave","text":"An enclave is a private region of memory protected from processes running at higher privilege levels. Enclaves are only found in specific hardware that implements Trusted Execution Environments (TEE), like Intel Software Guard Extensions (SGX). An enclave is a critical component of a worker node. Any Secret Node must meet these hardware requirements.","title":"Enclave"},{"location":"Glossary/#epoch","text":"A unit of time in the Enigma network in which a worker node is assigned to work on a set of secret contracts does not change, and in which the state encryption keys do not change.","title":"Epoch"},{"location":"Glossary/#guarded-code","text":"Code that runs inside an enclave , and executes with privacy and correctness guarantees. Guarded code typically has an unguarded counterpart.","title":"Guarded (Code):"},{"location":"Glossary/#secret-contract","text":"Secret contracts are smart contracts that provide confidentiality guarantees. The contract functions are executed over encrypted inputs and outputs. Whereas smart contracts are defined as self-executing contracts with the terms of the agreement between parties being directly written into lines of code , secret contracts add privacy to the data submitted to these contracts. While the code of secret contracts remains public and auditable, the inputs and outputs to the contract are encrypted and hidden from public view. Secret contracts thus provide data privacy and verifiable computation. Secret contracts exist across a distributed, decentralized blockchain network ( Enigma ) and permit trusted and privacy-preserving transactions and agreements to be carried out among disparate, anonymous parties without the need for a central authority, legal system, or external enforcement mechanism.","title":"Secret Contract"},{"location":"Glossary/#task","text":"A single computation, also defined as a secret contract function call.","title":"Task"},{"location":"Glossary/#task-receipt","text":"A publicly verifiable proof that a task has been computed by an uncompromised enclave with all intended inputs.","title":"Task Receipt"},{"location":"Glossary/#task-record","text":"The record of a task stored on the Ethereum network for the purposes of: Ordering Fee Payment Token deposits (for payable functions)","title":"Task Record"},{"location":"Glossary/#unguarded-code","text":"Code that executes outside of an enclave , providing an interface between the code that runs inside the enclave ( guarded ) and the outside world. Unguarded code does not provide neither correctness nor privacy guarantees.","title":"Unguarded (Code):"},{"location":"Glossary/#user-node","text":"Node from the Enigma network through which a dApp user interfaces with the network. The user node brokers data flows between the dApp user, the worker node and other network participants using the peer-to-peer network protocol. dApp users can freely choose their user nodes through which they interact with the network. It may happen that the user node becomes the worker node for a given taks, but only if it happened to be randomly selected by the network.","title":"User Node"},{"location":"Glossary/#worker-or-worker-node","text":"Secret Node of the Enigma network selected to execute a task inside an enclave , characterized as follows: A task is only assigned one worker insofar as the worker meets the task\u2019s service level agreement A contract is only assigned one worker per epoch insofar as the worker successfully executes the tasks assigned.","title":"Worker or Worker Node"},{"location":"IntroductionToDeployment/","text":"Deploying the Enigma Network \ud83d\udce1 Discovery can currently be deployed in two ways: Developer Mode : a series of containers in a Docker environment. This is also known as \"Simulation Mode\" because it does not require you to have hardware SGX support (meaning yes, you can develop on your macbook!). Hardware Mode : This mode requires hardware-level compatibility (see \"System Requirements\"). This is useful for users who may want to run Secret Nodes. For a step-by-step walkthrough of the \"developer mode\" deployment process, see our Getting Started guide. \ud83e\udd1eDiscovery will be also soon deployed to a public Ethereum testnet, giving you the opportunity to test your applications in the wild on a network of nodes, and streamlining your development options. Stay tuned! \ud83d\udcfa","title":"Deploying the Enigma Network  \ud83d\udce1"},{"location":"IntroductionToDeployment/#deploying-the-enigma-network","text":"Discovery can currently be deployed in two ways: Developer Mode : a series of containers in a Docker environment. This is also known as \"Simulation Mode\" because it does not require you to have hardware SGX support (meaning yes, you can develop on your macbook!). Hardware Mode : This mode requires hardware-level compatibility (see \"System Requirements\"). This is useful for users who may want to run Secret Nodes. For a step-by-step walkthrough of the \"developer mode\" deployment process, see our Getting Started guide. \ud83e\udd1eDiscovery will be also soon deployed to a public Ethereum testnet, giving you the opportunity to test your applications in the wild on a network of nodes, and streamlining your development options. Stay tuned! \ud83d\udcfa","title":"Deploying the Enigma Network  \ud83d\udce1"},{"location":"IntroductionToEnigmaJS/","text":"Enigma-JS Library \ud83d\udd0d The Enigma-JS Library gives developers the tools to deploy, interact with, and submit tasks to secret contracts on the Enigma network. Tasks are initiated by end-users of Ethereum applications. Enigma-JS enables developers to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. submit tasks to ENG network and receive encrypted outputs that can be decrypted by the user \ud83e\udd1e Note: The Enigma Network has its own secret contracts. The business logic of a computation task is contained in a secret contract, which is deployed on the Enigma Network. This is in contrast to having this logic in the function of an Ethereum smart contract. This is more powerful for many reasons; notably, a secret contract may store an encrypted state. Secret Contact Execution Process Computation Tasks When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks. Worker Verification In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. \ud83e\udd1eA worker is an Enigma Node-- it will execute the computation over the data submitted in the task and return an encrypted result. The node-runner does not see the data at any time. On-Chain Computation Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas . Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results. Task Verification A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: 1. The current epoch ends 2. A function in the task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. \ud83e\udd1eEthereum does not store the tasks results nor the encrypted state deltas , only hashes from which nodes can verify the integrity of their own data.","title":"About EnigmaJS"},{"location":"IntroductionToEnigmaJS/#enigma-js-library","text":"The Enigma-JS Library gives developers the tools to deploy, interact with, and submit tasks to secret contracts on the Enigma network. Tasks are initiated by end-users of Ethereum applications. Enigma-JS enables developers to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. submit tasks to ENG network and receive encrypted outputs that can be decrypted by the user \ud83e\udd1e Note: The Enigma Network has its own secret contracts. The business logic of a computation task is contained in a secret contract, which is deployed on the Enigma Network. This is in contrast to having this logic in the function of an Ethereum smart contract. This is more powerful for many reasons; notably, a secret contract may store an encrypted state.","title":"Enigma-JS Library \ud83d\udd0d"},{"location":"IntroductionToEnigmaJS/#secret-contact-execution-process","text":"","title":"Secret Contact Execution Process"},{"location":"IntroductionToEnigmaJS/#computation-tasks","text":"When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks.","title":"Computation Tasks"},{"location":"IntroductionToEnigmaJS/#worker-verification","text":"In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. \ud83e\udd1eA worker is an Enigma Node-- it will execute the computation over the data submitted in the task and return an encrypted result. The node-runner does not see the data at any time.","title":"Worker Verification"},{"location":"IntroductionToEnigmaJS/#on-chain-computation","text":"Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas . Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results.","title":"On-Chain Computation"},{"location":"IntroductionToEnigmaJS/#task-verification","text":"A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: 1. The current epoch ends 2. A function in the task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. \ud83e\udd1eEthereum does not store the tasks results nor the encrypted state deltas , only hashes from which nodes can verify the integrity of their own data.","title":"Task Verification"},{"location":"IntroductionToReference/","text":"Enigma Protocol Components \ud83d\udcd6 The Enigma Protocol is made up of several distinct components, each with their own repository. This section gives an overview of what is contained in each repo, and its purpose in the protocol. Enigma Smart Contract and Library This repository includes the JavaScript Enigma Library, which provides the interface that secret contract and dApp developers use to interact with the Enigma protocol. The source code is written in ECMAScript 6 (ES6) and comes prebundled with Webpack, and is exported in UMD format to provide universal functionality. The repository also includes more than 100 unit tests that both provide up to 98% code coverage, as well as comprehensively describes the functions provided both by the Enigma Library and the Enigma Contract. This repository also includes the Enigma smart contract written in Solidity, which implements the consensus layer for the Discovery release of the Enigma Protocol. Due to the limitations of EVM (Etherium Virtual Machine) as well as the complexity of the contract itself, several components have been broken down into modular contracts and libraries that come together into what is referred to as the Enigma Contract . One instance of this contract will be first deployed on the Ethereum testnet, and once more later on mainnet release. Enigma Core The code of this repository, as its name would imply, lies at the core of the Enigma Protocol. Written in Rust, it includes the code that runs both the inside (trusted) of the enclave and the outside (untrusted), and is responsible for interfacing with the rest of the Enigma Network. This repository also includes the Principal Node that runs inside a trusted enclave, and manages the keys to encrypt the state for all contracts in each epoch. It responds to legitimate requests from all other enclaves in the Enigma network for the encryption keys assigned to any such nodes. Both the enclaves and the principal node come packaged with support for 'simulation mode'. This mode allows for dApp developers to test secret contracts and interact with the libraries in a non-live environment without Intel SGX enabled hardware, thus allowing for easier cross-platform and legacy support. Please note that once the Enigma network has been deployed on testnet and mainnet, only enclaves running in hardware mode (on hosts with SGX enabled) will be able to join the Enigma network. Enigma Peer-to-Peer (P2P) Written in Javascript and forking off libp2p, this repository provides each of the above described enclaves with the peer-to-peer network functionality, thus forming the decentralised network. While both Enigma-Core and Enigma-P2P typically run on the same host, they are divided into two separate repositories for two reasons: provide very different functionality, and are coded in different languages (Rust and Javascript, respectively). Enigma-P2P runs in Node.js and provides a command line interface (CLI), although it is most commonly initialised automatically from a configuration file. The Enigma-P2P packages various autonomous runtimes that communicate between each other through a main controller. This communication is facilitated via both bi-directional message-sending tunnels called channels , as well as through actions , which are predefined messages that have a specific function attached to them. This infrastructure is optimized for asynchronous communication that reacts in real-time to notifications sent between the various components. This repository organizes its code into various cargo crates, providing several different components: the Enigma implementation of the WebAssembly (WASM) interpreter in Rust, the Enigma Runtime, cryptographic (AES, ECDSA, ECDH) and hashing (Keccak256) libraries, as well as the Remote Attestation client.","title":"Enigma Components"},{"location":"IntroductionToReference/#enigma-protocol-components","text":"The Enigma Protocol is made up of several distinct components, each with their own repository. This section gives an overview of what is contained in each repo, and its purpose in the protocol.","title":"Enigma Protocol Components \ud83d\udcd6"},{"location":"IntroductionToReference/#enigma-smart-contract-and-library","text":"This repository includes the JavaScript Enigma Library, which provides the interface that secret contract and dApp developers use to interact with the Enigma protocol. The source code is written in ECMAScript 6 (ES6) and comes prebundled with Webpack, and is exported in UMD format to provide universal functionality. The repository also includes more than 100 unit tests that both provide up to 98% code coverage, as well as comprehensively describes the functions provided both by the Enigma Library and the Enigma Contract. This repository also includes the Enigma smart contract written in Solidity, which implements the consensus layer for the Discovery release of the Enigma Protocol. Due to the limitations of EVM (Etherium Virtual Machine) as well as the complexity of the contract itself, several components have been broken down into modular contracts and libraries that come together into what is referred to as the Enigma Contract . One instance of this contract will be first deployed on the Ethereum testnet, and once more later on mainnet release.","title":"Enigma Smart Contract and Library"},{"location":"IntroductionToReference/#enigma-core","text":"The code of this repository, as its name would imply, lies at the core of the Enigma Protocol. Written in Rust, it includes the code that runs both the inside (trusted) of the enclave and the outside (untrusted), and is responsible for interfacing with the rest of the Enigma Network. This repository also includes the Principal Node that runs inside a trusted enclave, and manages the keys to encrypt the state for all contracts in each epoch. It responds to legitimate requests from all other enclaves in the Enigma network for the encryption keys assigned to any such nodes. Both the enclaves and the principal node come packaged with support for 'simulation mode'. This mode allows for dApp developers to test secret contracts and interact with the libraries in a non-live environment without Intel SGX enabled hardware, thus allowing for easier cross-platform and legacy support. Please note that once the Enigma network has been deployed on testnet and mainnet, only enclaves running in hardware mode (on hosts with SGX enabled) will be able to join the Enigma network.","title":"Enigma Core"},{"location":"IntroductionToReference/#enigma-peer-to-peer-p2p","text":"Written in Javascript and forking off libp2p, this repository provides each of the above described enclaves with the peer-to-peer network functionality, thus forming the decentralised network. While both Enigma-Core and Enigma-P2P typically run on the same host, they are divided into two separate repositories for two reasons: provide very different functionality, and are coded in different languages (Rust and Javascript, respectively). Enigma-P2P runs in Node.js and provides a command line interface (CLI), although it is most commonly initialised automatically from a configuration file. The Enigma-P2P packages various autonomous runtimes that communicate between each other through a main controller. This communication is facilitated via both bi-directional message-sending tunnels called channels , as well as through actions , which are predefined messages that have a specific function attached to them. This infrastructure is optimized for asynchronous communication that reacts in real-time to notifications sent between the various components. This repository organizes its code into various cargo crates, providing several different components: the Enigma implementation of the WebAssembly (WASM) interpreter in Rust, the Enigma Runtime, cryptographic (AES, ECDSA, ECDH) and hashing (Keccak256) libraries, as well as the Remote Attestation client.","title":"Enigma Peer-to-Peer (P2P)"},{"location":"KeyManagement/","text":"Key Management \ud83d\udddd All data (in flight or at rest) must be encrypted at all times except inside of enclaves at computation time. Since any node must be able to work on any encrypted data, all data must be encrypted using keys sharable to all nodes. Key Concepts and Definitions Here is a description of the key management model broken down by role. User Signing Key (asymmetric): basically an Ethereum key that can be used to uniquely identify the user submitting the request. Encryption key (asymmetric): the key used to derive an input/output key using ECDH (Elliptic-curve Diffie\u2013Hellman). Worker/Enclave Signing key (asymmetric): the key used to prove computations have happened inside the enclave (which is attached to the quote). Encryption key - asymmetric, the key used to derive an input/output key using ECDH (Elliptic-curve Diffie\u2013Hellman). Master key (symmetric): a key used to derive other State keys (this can easily be done for example by setting contract_state_key := H(master_key || contract_id) State key (symmetric): Shared AES-256 key per contract (right now everyone shares it, later on will be sharded). If it\u2019s generated from the master key, this can be done on the fly and does not need to be stored. Shared keys (fresh for every task) Input key (symmetric, derived): Worker has a permanent pubkey which is known. User uses that + its private key to generate a unique symmetric key for encrypting the argument. User can send its pubkey with the tx. We can use the taskid to make it fresh. Output key (symmetric, derived): If there\u2019s a return argument, then the same as #1 but in reverse happens - the worker can generate a new symmetric key from its private key and the user\u2019s pubkey. We can use the taskid to make it fresh.","title":"Key Management"},{"location":"KeyManagement/#key-management","text":"All data (in flight or at rest) must be encrypted at all times except inside of enclaves at computation time. Since any node must be able to work on any encrypted data, all data must be encrypted using keys sharable to all nodes.","title":"Key Management  \ud83d\udddd"},{"location":"KeyManagement/#key-concepts-and-definitions","text":"Here is a description of the key management model broken down by role. User Signing Key (asymmetric): basically an Ethereum key that can be used to uniquely identify the user submitting the request. Encryption key (asymmetric): the key used to derive an input/output key using ECDH (Elliptic-curve Diffie\u2013Hellman). Worker/Enclave Signing key (asymmetric): the key used to prove computations have happened inside the enclave (which is attached to the quote). Encryption key - asymmetric, the key used to derive an input/output key using ECDH (Elliptic-curve Diffie\u2013Hellman). Master key (symmetric): a key used to derive other State keys (this can easily be done for example by setting contract_state_key := H(master_key || contract_id) State key (symmetric): Shared AES-256 key per contract (right now everyone shares it, later on will be sharded). If it\u2019s generated from the master key, this can be done on the fly and does not need to be stored. Shared keys (fresh for every task) Input key (symmetric, derived): Worker has a permanent pubkey which is known. User uses that + its private key to generate a unique symmetric key for encrypting the argument. User can send its pubkey with the tx. We can use the taskid to make it fresh. Output key (symmetric, derived): If there\u2019s a return argument, then the same as #1 but in reverse happens - the worker can generate a new symmetric key from its private key and the user\u2019s pubkey. We can use the taskid to make it fresh.","title":"Key Concepts and Definitions"},{"location":"NetworkSetup/","text":"Network Setup In this tutorial, you will install and set up the Enigma developer testnet in software mode (appropriate for computers without SGX hardware support) Set up developer environment npm i -g @enigmampc/discovery-cli Uses npm to globally install the discovery-cli , a command line interface (CLI) for the Enigma protocol\u2019s Discovery release dev environment Create and navigate to a directory in which we will write our project code: mkdir path /millionaires_problem_demo cd path /millionaires_problem_demo Initialize this directory as an Enigma project by running discovery init . This command pulls the necessary pre-built docker images to run the Enigma testnet locally. When asked whether to set up the environment in the current folder, choose Y for yes. When asked whether to use hardware mode (HW) or simulation mode (SW), we will select sw . Choose Y to allow the docker images to be pulled to your machine\u200a\u2014\u200aif this is your first time creating an Enigma project and/or pulling these docker images, this may take ~15\u201320 minutes. This process has auto-generated scaffolding that should be familiar to users with experience working with Truffle). build : All of our compiled build files are written here and organized by type depending on whether they are Enigma protocol contracts, Ethereum smart contracts, or Enigma secret contracts (often abbreviated ESC as a heads up) migrations : Our migrations files, much like you would see in a Truffle environment smart_contracts : Any Ethereum smart contracts central to your dApp logic, with an existing example contract, Sample.sol secret_contracts : Any Enigma secret contracts central to your dApp logic, with an existing example Rust library simple_addition . We have included a Cargo.toml.template file which you can use as a foundation for your custom library\u2019s Cargo.toml specification. test : Any unit tests for your contracts Within our Discovery-initialized project, you are able to: Start the network\u200a\u2014\u200a discovery start Stop the network\u200a\u2014\u200a discovery stop","title":"Deploy Discovery"},{"location":"NetworkSetup/#network-setup","text":"In this tutorial, you will install and set up the Enigma developer testnet in software mode (appropriate for computers without SGX hardware support)","title":"Network Setup"},{"location":"NetworkSetup/#set-up-developer-environment","text":"npm i -g @enigmampc/discovery-cli Uses npm to globally install the discovery-cli , a command line interface (CLI) for the Enigma protocol\u2019s Discovery release dev environment Create and navigate to a directory in which we will write our project code: mkdir path /millionaires_problem_demo cd path /millionaires_problem_demo Initialize this directory as an Enigma project by running discovery init . This command pulls the necessary pre-built docker images to run the Enigma testnet locally. When asked whether to set up the environment in the current folder, choose Y for yes. When asked whether to use hardware mode (HW) or simulation mode (SW), we will select sw . Choose Y to allow the docker images to be pulled to your machine\u200a\u2014\u200aif this is your first time creating an Enigma project and/or pulling these docker images, this may take ~15\u201320 minutes. This process has auto-generated scaffolding that should be familiar to users with experience working with Truffle). build : All of our compiled build files are written here and organized by type depending on whether they are Enigma protocol contracts, Ethereum smart contracts, or Enigma secret contracts (often abbreviated ESC as a heads up) migrations : Our migrations files, much like you would see in a Truffle environment smart_contracts : Any Ethereum smart contracts central to your dApp logic, with an existing example contract, Sample.sol secret_contracts : Any Enigma secret contracts central to your dApp logic, with an existing example Rust library simple_addition . We have included a Cargo.toml.template file which you can use as a foundation for your custom library\u2019s Cargo.toml specification. test : Any unit tests for your contracts Within our Discovery-initialized project, you are able to: Start the network\u200a\u2014\u200a discovery start Stop the network\u200a\u2014\u200a discovery stop","title":"Set up developer environment"},{"location":"NewForDiscovery/","text":"What's New in Discovery \ud83c\udf81 The Discovery release of the Enigma protocol provides the following features: Secret State Secret contracts are capable of maintaining a state. Encrypted data persists across separate private computations or different tasks. Stateful contracts enable many more use cases than stateless computations (like secret tokens). Secret Contracts are seperate from Smart Contracts The Enigma network performs computation and storage, using Ethereum only for consensus and a shared ledger. This means that secret contracts have their own runtime (modified EVM) and programming language (Rust, instead of Solidity). Private Outputs In addition to private inputs, the network now supports storage of computation outputs. The contract state is stored (encrypted) on-chain and results can be encrypted directly for the dApp user. Economic Incentives Each node receives a financial reward for participating in the network. Gas Cost Optimization On Ethereum, gas cost is based on computation units associated with each opcode . The STORAGEADD opcode is the most expensive at 20k gas for each 32 bytes of data. Secret contracts should be significantly cheaper in gas than they were in the previous MVT release due to the following modifications: Inputs are not stored in the contract, only the taskId (a hash of inputs). The taskId is generated from inputs in the worker\u2019s enclave to ensure their integrity Outputs are not stored in the contract. On chain verification of the results still takes place but using a hash of the results. Ethereum Integration These features maintain interoperability with Ethereum: Token Transfers : Calling a payable secret contract function may involve an arbitrary ERC20 token deposit. Tokens are locked in the contract state until explicitly transferred to an Ethereum address in the secret contract business logic. Function Calls : Secret Contracts may call arbitrary functions of smart contract deployed on Ethereum. Contract Attributes Discovery supports the storage of system attributes (metadata) about each contract. To illustrate their utility, these attributes include but may not be limited to: A list of workers assigned to each contract which is useful for key management. The contract bytecode (or a reference to it) A mapping between each attribute and its position in the state array. Reference to external storage (like s3 or IPFS) if we build support for sealed data stored externally.","title":"About Discovery"},{"location":"NewForDiscovery/#whats-new-in-discovery","text":"The Discovery release of the Enigma protocol provides the following features:","title":"What's New in Discovery \ud83c\udf81"},{"location":"NewForDiscovery/#secret-state","text":"Secret contracts are capable of maintaining a state. Encrypted data persists across separate private computations or different tasks. Stateful contracts enable many more use cases than stateless computations (like secret tokens).","title":"Secret State"},{"location":"NewForDiscovery/#secret-contracts-are-seperate-from-smart-contracts","text":"The Enigma network performs computation and storage, using Ethereum only for consensus and a shared ledger. This means that secret contracts have their own runtime (modified EVM) and programming language (Rust, instead of Solidity).","title":"Secret Contracts are seperate from Smart Contracts"},{"location":"NewForDiscovery/#private-outputs","text":"In addition to private inputs, the network now supports storage of computation outputs. The contract state is stored (encrypted) on-chain and results can be encrypted directly for the dApp user.","title":"Private Outputs"},{"location":"NewForDiscovery/#economic-incentives","text":"Each node receives a financial reward for participating in the network.","title":"Economic Incentives"},{"location":"NewForDiscovery/#gas-cost-optimization","text":"On Ethereum, gas cost is based on computation units associated with each opcode . The STORAGEADD opcode is the most expensive at 20k gas for each 32 bytes of data. Secret contracts should be significantly cheaper in gas than they were in the previous MVT release due to the following modifications: Inputs are not stored in the contract, only the taskId (a hash of inputs). The taskId is generated from inputs in the worker\u2019s enclave to ensure their integrity Outputs are not stored in the contract. On chain verification of the results still takes place but using a hash of the results.","title":"Gas Cost Optimization"},{"location":"NewForDiscovery/#ethereum-integration","text":"These features maintain interoperability with Ethereum: Token Transfers : Calling a payable secret contract function may involve an arbitrary ERC20 token deposit. Tokens are locked in the contract state until explicitly transferred to an Ethereum address in the secret contract business logic. Function Calls : Secret Contracts may call arbitrary functions of smart contract deployed on Ethereum.","title":"Ethereum Integration"},{"location":"NewForDiscovery/#contract-attributes","text":"Discovery supports the storage of system attributes (metadata) about each contract. To illustrate their utility, these attributes include but may not be limited to: A list of workers assigned to each contract which is useful for key management. The contract bytecode (or a reference to it) A mapping between each attribute and its position in the state array. Reference to external storage (like s3 or IPFS) if we build support for sealed data stored externally.","title":"Contract Attributes"},{"location":"RustResources/","text":"Other Rust Resources \ud83d\uddfa\ufe0f Learning a new language is an investment, and we think Rust is well worth it. Here are some resources to get you up to speed and building with Rust. The Rust Book A concise, and often light-hearted primer and reference resource.","title":"Other Rust Resources \ud83d\uddfa\ufe0f"},{"location":"RustResources/#other-rust-resources","text":"Learning a new language is an investment, and we think Rust is well worth it. Here are some resources to get you up to speed and building with Rust. The Rust Book A concise, and often light-hearted primer and reference resource.","title":"Other Rust Resources \ud83d\uddfa\ufe0f"},{"location":"RustWalkthrough/","text":"An Introduction to Rust To help developers who are new to Rust or the Enigma protocol get a firm understanding of how secret contracts are written, this section outlines how to write a standalone Rust program that will be used to solve a classic connundrum - Yao's Millionaire Problem . To begin, you will need to ensure that you have Rust installed on your system, as well as a basic understanding of how Cargo operates. Note that there are several Rust features and concepts mentioned in the sections below, some of which only lightly touched on - if you would like to learn more about syntax or the language itself, it is recomended to consult the open-source Rust Book , which contains a variety of great examples and explanations curated by the community itself. For the full source code of the program below, see this repository . Setting Up In your terminal, issue the command cargo new rust_millionaires_problem to create a new project. Enter your new project directory with the command cd rust_millionaires_problem . Within this new directory there is a file named Cargo.toml . This is your project manifest , and it contains information about the author, versioning and dependencies. This should have been autopopulated from your Rust installation, though ensure the contents are similar to this: [package] name = rust_millionaires_demo version = 0.1.0 authors = [ name email ] [dependencies] Program Design As with all programs, we must break down the problem at hand and address each component individually. The intended logic is depicted in the graphic below. This basic flow can be represented in four steps: Creating a new Millionaires\u2019 Problem (this object should maintain a list of millionaires) Add millionaire 1 (object containing address / net worth) with name Bob and net worth 1,000,000 Add millionaire 2 (object containing address / net worth) with name Alice and net worth 2,000,000 Compute the richest millionaire, returning the appropriate address/name Writing your Program Data Structs Structs are data types that let you package together multiple related values and reference them with attribute fields and one collective name. To begin writing our program, we will be implementing a struct that will represent the Millionaires Problem itself. To create this struct, open src/lib.rs in your text editor and replace the contents with the following: pub struct MillionairesProblem { millionaires: Vec Millionaire , } This implements a basic struct with a single field named Millionaire . Next, a second struct must be implemented to represent the individual millionaires. This time two attribute fields will be added, one to track each millionaires address, and the other for net worth. pub struct Millionaire { address: String, // field name : field type net_worth: u64, // field name : field type } Function and Method Implementation We must now implement our programs primary logic - generating the millionaires problem itself. To do this we create a function , and place it inside a implementation block like so: impl MillionairesProblem { pub fn new() - MillionairesProblem { MillionairesProblem { millionaires: Vec::new(), } } } The last line of this section creates an empty vector when the Millionaires Problem is initialised. Also note that the impl block has the same name as the MillionairesProblem struct we defined above, and thus functions and methods we implement here refer to the same context. Adding a Millionaire In order to add a new millionaire, we will define a method in the impl block like this: pub fn add_millionaire( mut self, address: String, net_worth: u64) { let millionaire = Millionaire { address, net_worth, }; self.millionaires.push(millionaire); } NOTE: Methods, unlike traditional functions and associated functions, always start with self as the first parameter, which represents the instance of the struct this method is being called on. In this case, we prefix self with mut . The touches upon the topic of ownership , a big contributor to Rusts memory efficiency. It is reccomended to take the time to understand ownership, and how it can improve your development experience down the road. Computing the Richest Millionaire The final method we will write is to compute the richest millionaire. pub fn compute_richest( self) - str { match self.millionaires.iter().max_by_key(|m| m.net_worth) { Some(millionaire) = millionaire.address[..], None = None } } Summary Congratulations, you've just made your first Rust library! To summarize, we first created two structs: MillionairesProblem and Millionaire , then created an impl block to further the functionality of the MillionairesProblem , and two methods to allow us to add a new millionaire and compute the richest millionaire.","title":"Learn Rust"},{"location":"RustWalkthrough/#an-introduction-to-rust","text":"To help developers who are new to Rust or the Enigma protocol get a firm understanding of how secret contracts are written, this section outlines how to write a standalone Rust program that will be used to solve a classic connundrum - Yao's Millionaire Problem . To begin, you will need to ensure that you have Rust installed on your system, as well as a basic understanding of how Cargo operates. Note that there are several Rust features and concepts mentioned in the sections below, some of which only lightly touched on - if you would like to learn more about syntax or the language itself, it is recomended to consult the open-source Rust Book , which contains a variety of great examples and explanations curated by the community itself. For the full source code of the program below, see this repository .","title":"An Introduction to Rust"},{"location":"RustWalkthrough/#setting-up","text":"In your terminal, issue the command cargo new rust_millionaires_problem to create a new project. Enter your new project directory with the command cd rust_millionaires_problem . Within this new directory there is a file named Cargo.toml . This is your project manifest , and it contains information about the author, versioning and dependencies. This should have been autopopulated from your Rust installation, though ensure the contents are similar to this: [package] name = rust_millionaires_demo version = 0.1.0 authors = [ name email ] [dependencies]","title":"Setting Up"},{"location":"RustWalkthrough/#program-design","text":"As with all programs, we must break down the problem at hand and address each component individually. The intended logic is depicted in the graphic below. This basic flow can be represented in four steps: Creating a new Millionaires\u2019 Problem (this object should maintain a list of millionaires) Add millionaire 1 (object containing address / net worth) with name Bob and net worth 1,000,000 Add millionaire 2 (object containing address / net worth) with name Alice and net worth 2,000,000 Compute the richest millionaire, returning the appropriate address/name","title":"Program Design"},{"location":"RustWalkthrough/#writing-your-program","text":"","title":"Writing your Program"},{"location":"RustWalkthrough/#data-structs","text":"Structs are data types that let you package together multiple related values and reference them with attribute fields and one collective name. To begin writing our program, we will be implementing a struct that will represent the Millionaires Problem itself. To create this struct, open src/lib.rs in your text editor and replace the contents with the following: pub struct MillionairesProblem { millionaires: Vec Millionaire , } This implements a basic struct with a single field named Millionaire . Next, a second struct must be implemented to represent the individual millionaires. This time two attribute fields will be added, one to track each millionaires address, and the other for net worth. pub struct Millionaire { address: String, // field name : field type net_worth: u64, // field name : field type }","title":"Data Structs"},{"location":"RustWalkthrough/#function-and-method-implementation","text":"We must now implement our programs primary logic - generating the millionaires problem itself. To do this we create a function , and place it inside a implementation block like so: impl MillionairesProblem { pub fn new() - MillionairesProblem { MillionairesProblem { millionaires: Vec::new(), } } } The last line of this section creates an empty vector when the Millionaires Problem is initialised. Also note that the impl block has the same name as the MillionairesProblem struct we defined above, and thus functions and methods we implement here refer to the same context.","title":"Function and Method Implementation"},{"location":"RustWalkthrough/#adding-a-millionaire","text":"In order to add a new millionaire, we will define a method in the impl block like this: pub fn add_millionaire( mut self, address: String, net_worth: u64) { let millionaire = Millionaire { address, net_worth, }; self.millionaires.push(millionaire); } NOTE: Methods, unlike traditional functions and associated functions, always start with self as the first parameter, which represents the instance of the struct this method is being called on. In this case, we prefix self with mut . The touches upon the topic of ownership , a big contributor to Rusts memory efficiency. It is reccomended to take the time to understand ownership, and how it can improve your development experience down the road.","title":"Adding a Millionaire"},{"location":"RustWalkthrough/#computing-the-richest-millionaire","text":"The final method we will write is to compute the richest millionaire. pub fn compute_richest( self) - str { match self.millionaires.iter().max_by_key(|m| m.net_worth) { Some(millionaire) = millionaire.address[..], None = None } }","title":"Computing the Richest Millionaire"},{"location":"RustWalkthrough/#summary","text":"Congratulations, you've just made your first Rust library! To summarize, we first created two structs: MillionairesProblem and Millionaire , then created an impl block to further the functionality of the MillionairesProblem , and two methods to allow us to add a new millionaire and compute the richest millionaire.","title":"Summary"},{"location":"SecretContractEngine/","text":"Secret Contract Engine \ud83d\ude82 Secret contracts are written in Rust and compiled to WebAssembly (abbreviated Wasm). The contract bytecode is stored unencrypted on Enigma with a hash on Ethereum. The hash of the bytecode will be used as its address. Benefits of this stack include: Well suited to execute general purpose tasks (e.g. machine learning algorithms) compared to a smart-contract-specific language like Solidity. Existing Parity pwasm implementation that can be used as a reference or partially reused. Contracts will be written in Rust which is consistent with our stack and that of other blockchains. Using a general purpose language and execution environment enables us to extend the smart contract features simply by creating new libraries. For example, we could create a library which executes web queries directly in the secret contract business logic. Contract Architecture We use wasmi - Parity WASM interpreter, which allows us to run general-purpose Wasm code. Baidu already did an adaptation of wasmi to SGX. We create Enigma runtime module for handling all state operations, and eng_wasm, which is an implementation of bindings to Enigma runtime. As required by wasmi, we create ImportResolver, which maps all functions that runtime supports to the corresponding contract import entries. We decided to use Solidity ABI format for input/output for the following reasons: Pwasm implementation uses Solidity ABI as well and may be reused. Ability to preserve the current functionality with Solidity contracts that use Solidity ABI. Despite the restrictions of the Solidity ABI types, the new version V2 should support more types, for example structs Technical Specification Structure For usage of runtime predefined module eng_wasm should be imported, which defines all operations on state. Constructor function to be called upon contract creation Functions Other requirements: Users should not write a \u201cmain\u201d call function in contract (like in pwasm). Contract-to-contract calls are not allowed except when at the end of the execution we want to call a contract on Ethereum. For this we can re-use what we did for a callback in MVT or what Parity does for intercalls. Gas calculation: We intend to reuse Parity mechanism of injection of the gas calculation into a contract. We prefer to build a mechanism that executes the computation while there is enough gas, and stops the execution otherwise. If this is difficult, maybe it\u2019s ok to do the gas calculation after the computation (although with some reasonable limits - halting problem) Compatibility: We decided to preserve the current functionality with Solidity contracts The Solidity contract compiled to EVM will be deployed on ethereum and on Enigma. For stateful functions users will create regular ethereum call transactions. For stateless functions there will be an additional option: to call the function through Enigma network as it is done in the case of Wasm contract. Since in both cases we use Solidity ABI, the call seems the same from the network perspective. The challenge: in the case of Solidity contract it is important not only to return results of the call to the user, but also to commit them on ethereum (for example in the case of secret voting).","title":"Secret Contract Engine"},{"location":"SecretContractEngine/#secret-contract-engine","text":"Secret contracts are written in Rust and compiled to WebAssembly (abbreviated Wasm). The contract bytecode is stored unencrypted on Enigma with a hash on Ethereum. The hash of the bytecode will be used as its address. Benefits of this stack include: Well suited to execute general purpose tasks (e.g. machine learning algorithms) compared to a smart-contract-specific language like Solidity. Existing Parity pwasm implementation that can be used as a reference or partially reused. Contracts will be written in Rust which is consistent with our stack and that of other blockchains. Using a general purpose language and execution environment enables us to extend the smart contract features simply by creating new libraries. For example, we could create a library which executes web queries directly in the secret contract business logic.","title":"Secret Contract Engine \ud83d\ude82"},{"location":"SecretContractEngine/#contract-architecture","text":"We use wasmi - Parity WASM interpreter, which allows us to run general-purpose Wasm code. Baidu already did an adaptation of wasmi to SGX. We create Enigma runtime module for handling all state operations, and eng_wasm, which is an implementation of bindings to Enigma runtime. As required by wasmi, we create ImportResolver, which maps all functions that runtime supports to the corresponding contract import entries. We decided to use Solidity ABI format for input/output for the following reasons: Pwasm implementation uses Solidity ABI as well and may be reused. Ability to preserve the current functionality with Solidity contracts that use Solidity ABI. Despite the restrictions of the Solidity ABI types, the new version V2 should support more types, for example structs","title":"Contract Architecture"},{"location":"SecretContractEngine/#technical-specification","text":"Structure For usage of runtime predefined module eng_wasm should be imported, which defines all operations on state. Constructor function to be called upon contract creation Functions Other requirements: Users should not write a \u201cmain\u201d call function in contract (like in pwasm). Contract-to-contract calls are not allowed except when at the end of the execution we want to call a contract on Ethereum. For this we can re-use what we did for a callback in MVT or what Parity does for intercalls. Gas calculation: We intend to reuse Parity mechanism of injection of the gas calculation into a contract. We prefer to build a mechanism that executes the computation while there is enough gas, and stops the execution otherwise. If this is difficult, maybe it\u2019s ok to do the gas calculation after the computation (although with some reasonable limits - halting problem) Compatibility: We decided to preserve the current functionality with Solidity contracts The Solidity contract compiled to EVM will be deployed on ethereum and on Enigma. For stateful functions users will create regular ethereum call transactions. For stateless functions there will be an additional option: to call the function through Enigma network as it is done in the case of Wasm contract. Since in both cases we use Solidity ABI, the call seems the same from the network perspective. The challenge: in the case of Solidity contract it is important not only to return results of the call to the user, but also to commit them on ethereum (for example in the case of secret voting).","title":"Technical Specification"},{"location":"SecretContractExamples/","text":"Examples \u26f7\ufe0f Millionaire's Problem #![no_std] #![allow(unused_attributes)] // TODO: Remove on future nightly https://github.com/rust-lang/rust/issues/60050 extern crate eng_wasm; extern crate eng_wasm_derive; extern crate rustc_hex as hex; #[macro_use] extern crate serde_derive; extern crate serde; use eng_wasm::*; use eng_wasm_derive::pub_interface; use serde::{Serialize, Deserialize}; // State key name millionaires holding a vector of Millionaire structs static MILLIONAIRES: str = millionaires ; // Struct representing a Millionaire #[derive(Serialize, Deserialize)] pub struct Millionaire { address: H256, // field containing 32 byte hash type for millionaire's address net_worth: U256, // field containing 32 byte uint for millionaire's net worth } // Public-facing secret contract function declarations #[pub_interface] pub trait ContractInterface{ fn add_millionaire(address: H256, net_worth: U256); fn compute_richest() - H256; } pub struct Contract; // Private functions accessible only by the secret contract impl Contract { // Read secret contract state to obtain vector of Millionaires (or new vector if uninitialized) fn get_millionaires() - Vec Millionaire { match read_state!(MILLIONAIRES) { Some(vec) = vec, None = Vec::new(), } } } impl ContractInterface for Contract { // Add millionaire with 32-byte hash type for address and 32-byte uint for net worth #[no_mangle] fn add_millionaire(address: H256, net_worth: U256) { // Read state to get vector of Millionaires let mut millionaires = Self::get_millionaires(); // Append a new Millionaire struct to this vector millionaires.push(Millionaire { address, net_worth, }); // Write the updated vector to contract's state write_state!(MILLIONAIRES = millionaires); } // Compute the richest millionaire by returning the 32-byte hash type for the address #[no_mangle] fn compute_richest() - H256 { // Read state to get vector of Millionaires and obtain the struct corresponding to the // richest millionaire by net worth match Self::get_millionaires().iter().max_by_key(|m| m.net_worth) { // Return millionaire's address Some(millionaire) = { millionaire.address }, // Return empty address None = U256::from(0).into(), } } } Calculator #![no_std] #![allow(unused_attributes)] // TODO: Remove on future nightly https://github.com/rust-lang/rust/issues/60050 extern crate eng_wasm; extern crate eng_wasm_derive; use eng_wasm::*; use eng_wasm_derive::pub_interface; #[pub_interface] pub trait ContractInterface{ fn add(a: U256, b: U256) - U256; fn sub(a: U256, b: U256) - U256; fn mul(a: U256, b: U256) - U256; fn div(a: U256, b: U256) - U256; } pub struct Contract; impl ContractInterface for Contract { #[no_mangle] fn add(a: U256, b: U256) - U256 { let res = a.checked_add(b); match res { Some(r) = r, None = panic!( addition overflow ), } } #[no_mangle] fn sub(a: U256, b: U256) - U256 { let res = a.checked_sub(b); match res { Some(r) = r, None = panic!( subtraction overflow ), } } #[no_mangle] fn mul(a: U256, b: U256) - U256 { let res = a.checked_mul(b); match res { Some(r) = r, None = panic!( multiple overflow ), } } #[no_mangle] fn div(a: U256, b: U256) - U256 { let res = a.checked_div(b); match res { Some(r) = r, None = panic!( division by zero ), } } } Voting #![no_std] #![allow(unused_attributes)] // https://github.com/rust-lang/rust/issues/60050 extern crate eng_wasm; extern crate eng_wasm_derive; extern crate rustc_hex; #[macro_use] extern crate serde_derive; extern crate serde; use eng_wasm::*; use eng_wasm_derive::pub_interface; use eng_wasm_derive::eth_contract; use eng_wasm::String; use std::collections::HashMap; use rustc_hex::ToHex; // VotingETH contract abi #[eth_contract( VotingETH.json )] struct EthContract; // State key name polls holding a vector of Poll structs static POLLS: str = polls ; // State key name voting_eth_addr holding eth address of VotingETH contract static VOTING_ETH_ADDR: str = voting_eth_addr ; // Public-facing secret contract function declarations #[pub_interface] pub trait ContractInterface{ fn construct(voting_eth_addr: H160); fn cast_vote(poll_id: U256, voter: H256, vote: U256); fn tally_poll(poll_id: U256); } pub struct Contract; // Private functions accessible only by the secret contract impl Contract { // Read secret contract state to obtain vector of Poll structs (or new vector if uninitialized) fn get_polls() - HashMap u64, HashMap String, U256 { read_state!(POLLS).unwrap_or_default() } // Read voting address of VotingETH contract fn get_voting_eth_addr() - String { read_state!(VOTING_ETH_ADDR).unwrap_or_default() } } impl ContractInterface for Contract { // Constructor function that takes in VotingETH ethereum contract address #[no_mangle] fn construct(voting_eth_addr: H160) { let voting_eth_addr_str: String = voting_eth_addr.to_hex(); write_state!(VOTING_ETH_ADDR = voting_eth_addr_str); } // Cast vote function that takes poll ID, voter address, and vote - calls back to ETH #[no_mangle] fn cast_vote(poll_id: U256, voter: H256, vote: U256) { let mut polls = Self::get_polls(); { let voter_info = polls.entry(poll_id.as_u64()).or_insert_with(HashMap::new); let key: String = voter.to_hex(); assert!(!(*voter_info).contains_key( key), user has already voted in poll ); (*voter_info).insert(key, vote); } write_state!(POLLS = polls); let voting_eth_addr: String = Self::get_voting_eth_addr(); let c = EthContract::new( voting_eth_addr); c.validateCastVote(poll_id); } // Tally poll function that takes poll ID - calls back to ETH #[no_mangle] fn tally_poll(poll_id: U256) { let polls = Self::get_polls(); let mut tallied_quorum: U256 = U256::zero(); if let Some(voter_info) = polls.get( poll_id.as_u64()) { for val in voter_info.values() { tallied_quorum = tallied_quorum.checked_add(*val).unwrap(); } tallied_quorum = tallied_quorum.checked_mul(100.into()).unwrap().checked_div(voter_info.len().into()).unwrap() } let voting_eth_addr: String = Self::get_voting_eth_addr(); let c = EthContract::new( voting_eth_addr); c.validateTallyPoll(poll_id, tallied_quorum); } } Coin Toss #![no_std] extern crate eng_wasm; extern crate eng_wasm_derive; use eng_wasm::*; use eng_wasm_derive::pub_interface; #[pub_interface] pub trait ContractInterface{ /// Flipping the coin. Uses true sgx randomness. fn flip() - bool; /// Player 1 commits to a coin value fn commit(bool); /// Player 2 guesses the value that player 1 was committed to. The commitment is removed. /// True is returned on successful guess. fn guess(guess: bool) - bool; } const COMMITMENT_KEY: 'static str = commitment ; pub struct Contract; impl ContractInterface for Contract { fn flip() - bool { let result: u8 = Rand::gen(); result % 2 == 1 } fn commit(commitment: bool) { let val: Option Value = read_state!(COMMITMENT_KEY); if val.is_none() { write_state!(COMMITMENT_KEY = commitment); } } fn guess(guess: bool) - bool { let val: Option Value = remove_from_state!(COMMITMENT_KEY); match val { Some(commitment) = commitment == guess, _ = false } } }","title":"Examples"},{"location":"SecretContractExamples/#examples","text":"","title":"Examples \u26f7\ufe0f"},{"location":"SecretContractExamples/#millionaires-problem","text":"#![no_std] #![allow(unused_attributes)] // TODO: Remove on future nightly https://github.com/rust-lang/rust/issues/60050 extern crate eng_wasm; extern crate eng_wasm_derive; extern crate rustc_hex as hex; #[macro_use] extern crate serde_derive; extern crate serde; use eng_wasm::*; use eng_wasm_derive::pub_interface; use serde::{Serialize, Deserialize}; // State key name millionaires holding a vector of Millionaire structs static MILLIONAIRES: str = millionaires ; // Struct representing a Millionaire #[derive(Serialize, Deserialize)] pub struct Millionaire { address: H256, // field containing 32 byte hash type for millionaire's address net_worth: U256, // field containing 32 byte uint for millionaire's net worth } // Public-facing secret contract function declarations #[pub_interface] pub trait ContractInterface{ fn add_millionaire(address: H256, net_worth: U256); fn compute_richest() - H256; } pub struct Contract; // Private functions accessible only by the secret contract impl Contract { // Read secret contract state to obtain vector of Millionaires (or new vector if uninitialized) fn get_millionaires() - Vec Millionaire { match read_state!(MILLIONAIRES) { Some(vec) = vec, None = Vec::new(), } } } impl ContractInterface for Contract { // Add millionaire with 32-byte hash type for address and 32-byte uint for net worth #[no_mangle] fn add_millionaire(address: H256, net_worth: U256) { // Read state to get vector of Millionaires let mut millionaires = Self::get_millionaires(); // Append a new Millionaire struct to this vector millionaires.push(Millionaire { address, net_worth, }); // Write the updated vector to contract's state write_state!(MILLIONAIRES = millionaires); } // Compute the richest millionaire by returning the 32-byte hash type for the address #[no_mangle] fn compute_richest() - H256 { // Read state to get vector of Millionaires and obtain the struct corresponding to the // richest millionaire by net worth match Self::get_millionaires().iter().max_by_key(|m| m.net_worth) { // Return millionaire's address Some(millionaire) = { millionaire.address }, // Return empty address None = U256::from(0).into(), } } }","title":"Millionaire's Problem"},{"location":"SecretContractExamples/#calculator","text":"#![no_std] #![allow(unused_attributes)] // TODO: Remove on future nightly https://github.com/rust-lang/rust/issues/60050 extern crate eng_wasm; extern crate eng_wasm_derive; use eng_wasm::*; use eng_wasm_derive::pub_interface; #[pub_interface] pub trait ContractInterface{ fn add(a: U256, b: U256) - U256; fn sub(a: U256, b: U256) - U256; fn mul(a: U256, b: U256) - U256; fn div(a: U256, b: U256) - U256; } pub struct Contract; impl ContractInterface for Contract { #[no_mangle] fn add(a: U256, b: U256) - U256 { let res = a.checked_add(b); match res { Some(r) = r, None = panic!( addition overflow ), } } #[no_mangle] fn sub(a: U256, b: U256) - U256 { let res = a.checked_sub(b); match res { Some(r) = r, None = panic!( subtraction overflow ), } } #[no_mangle] fn mul(a: U256, b: U256) - U256 { let res = a.checked_mul(b); match res { Some(r) = r, None = panic!( multiple overflow ), } } #[no_mangle] fn div(a: U256, b: U256) - U256 { let res = a.checked_div(b); match res { Some(r) = r, None = panic!( division by zero ), } } }","title":"Calculator"},{"location":"SecretContractExamples/#voting","text":"#![no_std] #![allow(unused_attributes)] // https://github.com/rust-lang/rust/issues/60050 extern crate eng_wasm; extern crate eng_wasm_derive; extern crate rustc_hex; #[macro_use] extern crate serde_derive; extern crate serde; use eng_wasm::*; use eng_wasm_derive::pub_interface; use eng_wasm_derive::eth_contract; use eng_wasm::String; use std::collections::HashMap; use rustc_hex::ToHex; // VotingETH contract abi #[eth_contract( VotingETH.json )] struct EthContract; // State key name polls holding a vector of Poll structs static POLLS: str = polls ; // State key name voting_eth_addr holding eth address of VotingETH contract static VOTING_ETH_ADDR: str = voting_eth_addr ; // Public-facing secret contract function declarations #[pub_interface] pub trait ContractInterface{ fn construct(voting_eth_addr: H160); fn cast_vote(poll_id: U256, voter: H256, vote: U256); fn tally_poll(poll_id: U256); } pub struct Contract; // Private functions accessible only by the secret contract impl Contract { // Read secret contract state to obtain vector of Poll structs (or new vector if uninitialized) fn get_polls() - HashMap u64, HashMap String, U256 { read_state!(POLLS).unwrap_or_default() } // Read voting address of VotingETH contract fn get_voting_eth_addr() - String { read_state!(VOTING_ETH_ADDR).unwrap_or_default() } } impl ContractInterface for Contract { // Constructor function that takes in VotingETH ethereum contract address #[no_mangle] fn construct(voting_eth_addr: H160) { let voting_eth_addr_str: String = voting_eth_addr.to_hex(); write_state!(VOTING_ETH_ADDR = voting_eth_addr_str); } // Cast vote function that takes poll ID, voter address, and vote - calls back to ETH #[no_mangle] fn cast_vote(poll_id: U256, voter: H256, vote: U256) { let mut polls = Self::get_polls(); { let voter_info = polls.entry(poll_id.as_u64()).or_insert_with(HashMap::new); let key: String = voter.to_hex(); assert!(!(*voter_info).contains_key( key), user has already voted in poll ); (*voter_info).insert(key, vote); } write_state!(POLLS = polls); let voting_eth_addr: String = Self::get_voting_eth_addr(); let c = EthContract::new( voting_eth_addr); c.validateCastVote(poll_id); } // Tally poll function that takes poll ID - calls back to ETH #[no_mangle] fn tally_poll(poll_id: U256) { let polls = Self::get_polls(); let mut tallied_quorum: U256 = U256::zero(); if let Some(voter_info) = polls.get( poll_id.as_u64()) { for val in voter_info.values() { tallied_quorum = tallied_quorum.checked_add(*val).unwrap(); } tallied_quorum = tallied_quorum.checked_mul(100.into()).unwrap().checked_div(voter_info.len().into()).unwrap() } let voting_eth_addr: String = Self::get_voting_eth_addr(); let c = EthContract::new( voting_eth_addr); c.validateTallyPoll(poll_id, tallied_quorum); } }","title":"Voting"},{"location":"SecretContractExamples/#coin-toss","text":"#![no_std] extern crate eng_wasm; extern crate eng_wasm_derive; use eng_wasm::*; use eng_wasm_derive::pub_interface; #[pub_interface] pub trait ContractInterface{ /// Flipping the coin. Uses true sgx randomness. fn flip() - bool; /// Player 1 commits to a coin value fn commit(bool); /// Player 2 guesses the value that player 1 was committed to. The commitment is removed. /// True is returned on successful guess. fn guess(guess: bool) - bool; } const COMMITMENT_KEY: 'static str = commitment ; pub struct Contract; impl ContractInterface for Contract { fn flip() - bool { let result: u8 = Rand::gen(); result % 2 == 1 } fn commit(commitment: bool) { let val: Option Value = read_state!(COMMITMENT_KEY); if val.is_none() { write_state!(COMMITMENT_KEY = commitment); } } fn guess(guess: bool) - bool { let val: Option Value = remove_from_state!(COMMITMENT_KEY); match val { Some(commitment) = commitment == guess, _ = false } } }","title":"Coin Toss"},{"location":"SecretContractWalkthrough/","text":"Creating a Secret Contract \ud83d\udcd0 Adi's secret contract walkthrough","title":"Creating a Secret Contract \ud83d\udcd0"},{"location":"SecretContractWalkthrough/#creating-a-secret-contract","text":"Adi's secret contract walkthrough","title":"Creating a Secret Contract \ud83d\udcd0"},{"location":"SecretContracts/","text":"Secret Contracts \ud83e\udd2b Secret contracts are self-executing contracts with encrypted inputs and outputs. Once deployed on the Enigma network, they are called by the end-users of decentralized applications and executed by Enigma nodes. Enigma Secret Contracts are written in Rust. If you are not familiar with Rust, check out our Rust walkthrough (which will also take you through developing your first Secret Contract). We highly encourage the Secret Contract Tutorial for first-time users. \ud83e\udd1e","title":"Overview"},{"location":"SecretContracts/#secret-contracts","text":"Secret contracts are self-executing contracts with encrypted inputs and outputs. Once deployed on the Enigma network, they are called by the end-users of decentralized applications and executed by Enigma nodes. Enigma Secret Contracts are written in Rust. If you are not familiar with Rust, check out our Rust walkthrough (which will also take you through developing your first Secret Contract). We highly encourage the Secret Contract Tutorial for first-time users. \ud83e\udd1e","title":"Secret Contracts \ud83e\udd2b"},{"location":"Walkthrough/","text":"Start Here \ud83d\udccd Discovery-cli is a Command Line Interface (CLI) for the Discovery Enigma Protocol development environment, and is the fastest way to get up and running with Enigma. This interface comes with application scaffolding to get you started with writing and deploying secret contracts. After you set up the network, see our Walkthrough sections for additional guidance. Installation npm install -g @enigmampc/discovery-cli Usage $ discovery command Commands: discovery init Initialize Enigma Discovery development environment discovery compile Compile Secret Contracts and Smart Contracts discovery migrate Migrate Secret Contracts and Smart Contracts discovery pull Pull the latest images for the containers in the network discovery start Launch the Discovery Docker network discovery stop Stop the network by stopping and removing all containers Options: --help Show help [boolean] --version Show version number [boolean] Uninstall npm remove -g @enigmampc/discovery-cli","title":"Quick Start"},{"location":"Walkthrough/#start-here","text":"Discovery-cli is a Command Line Interface (CLI) for the Discovery Enigma Protocol development environment, and is the fastest way to get up and running with Enigma. This interface comes with application scaffolding to get you started with writing and deploying secret contracts. After you set up the network, see our Walkthrough sections for additional guidance.","title":"Start Here \ud83d\udccd"},{"location":"Walkthrough/#installation","text":"npm install -g @enigmampc/discovery-cli","title":"Installation"},{"location":"Walkthrough/#usage","text":"$ discovery command Commands: discovery init Initialize Enigma Discovery development environment discovery compile Compile Secret Contracts and Smart Contracts discovery migrate Migrate Secret Contracts and Smart Contracts discovery pull Pull the latest images for the containers in the network discovery start Launch the Discovery Docker network discovery stop Stop the network by stopping and removing all containers Options: --help Show help [boolean] --version Show version number [boolean]","title":"Usage"},{"location":"Walkthrough/#uninstall","text":"npm remove -g @enigmampc/discovery-cli","title":"Uninstall"},{"location":"Walkthrough_secretContract/","text":"Writing a secret contract This walkthrough will take you through the process of initializing a project, creating a secret contract, and writing unit-tests for this contract. Setting Up Project Structure Start the network with\u200a discovery start This should only take 15\u201320 seconds (unless it is your first time, in which case it may take 3\u20134 minutes). Create a brand new Rust library containing our secret contract logic with the following command: cargo new secret_contracts/millionaires_problem --lib Copy and paste the contents of the secret_contracts/Cargo.toml.template file into the Cargo.toml file inside the library of secret_contracts/millionaires_problem that was just created. Under [dependencies] add this line: serde = \u201c1.0.84\u201d . The full Cargo.toml file should now read: [package] name = \"contract\" version = \"0.1.0\" [dependencies] eng-wasm = { git = \"https://github.com/enigmampc/enigma-core.git\", branch = \"develop\" } eng-wasm-derive = { git = \"https://github.com/enigmampc/enigma-core.git\", branch = \"develop\" } serde = \"1.0.84\" [lib] crate-type = [\"cdylib\"] [profile.release] panic = \"abort\" lto = true opt-level = \"z\" Writing the Secret Contract Open the lib.rs file located at secret_contracts/millionaires_problem/src/lib.rs Delete existing file contents. Add the following code. ` // Built-In Attributes #![no_std] ` All of our secret contracts exactly like this, because the SGX environment does not support all the features of Rust's standard library. [This attribute](https://medium.com/r/?url=http%3A%2F%2Frust%20import) removes the standard library from our program\u2019s prelude accordingly. Now add: ``` // Imports extern crate eng_wasm; extern crate eng_wasm_derive; extern crate serde; `` use eng_wasm::*; use eng_wasm_derive::pub_interface; use serde::{Serialize, Deserialize}; ``` This brings the following packages into scope: eng_wasm \u200a\u2014\u200aThis crate allows us to use the Enigma runtime, offering important functionalities including reading from state, writing to state, and printing. eng_wasm_derive \u200a\u2014\u200aThis crate provides functions exposed by the contract that can be called from the Enigma network and the ability to call functions of Ethereum contracts from a secret contract. eng_wasm_derive::pub_interface \u200a\u2014\u200aGives us the ability to add the #[pub_interface] trait to any public-facing functions within our secret contract. serde::{Serialize, Deserialize} \u200a\u2014\u200aAllows us to serialize and deserialize custom struct types. Next add: // Encrypted state keys static MILLIONAIRES: str = \"millionaires\"; Secret contracts can maintain encrypted state. Our contract needs to maintain a list of millionaires in state, which must have an entry key, value pair that looks something like this: \"millionaires\", vector of Millionaire structs . As shown, \"millionaires\" is the key into this encrypted state maintaining the list of millionaires. Below the state keys, add: ~~~ // Structs #[derive(Serialize, Deserialize)] pub struct Millionaire { address: H160, net_worth: U256, } ~~~ A millionaire\u2019s metadata consists the following attributes: 1. ETH address 2. net_worth Note the variable types. address is of type H160 , which corresponds to a 160-bit/20-byte hash value (recall that ETH addresses are 20 bytes long) and net_worth is of type U256 , which corresponds to a 256-bit/32-byte value. (For those of you with Solidity backgrounds, you can think of these as address and uint256 types, respectively.) Now add: // Public struct Contract which will consist of private and public- facing secret contract functions pub struct Contract; This initializes a public struct called Contract which can consist of both private and public-facing functions to be defined later. Add: // Private functions accessible only by the secret contract impl Contract { fn get_millionaires() - Vec Millionaire { read_state!(MILLIONAIRES).unwrap_or_default() } } This code implements the private methods for the secret contract. get_millionaires() returns Vec Millionaire , a vector of Millionaire structs stored in state. Note how we read from secret contract state with the macro read_state!( key ) . The unwrap_or_default() method returns the contained value, otherwise the default for that type. Next, add: ` // Public trait defining public-facing secret contract functions #[pub_interface] pub trait ContractInterface{ fn add_millionaire(address: H160, net_worth: U256); fn compute_richest() - H160; } ` This section declares the public-facing secret contract signatures by creating a public trait with the #[pub_interface] macro. In this case, there is now a trait called ContractInterface and two method definitions: add_millionaire \u200a\u2014\u200aAdd/register a new millionaire with an Ethereum address ( H160 ) and net worth ( U256 ) compute_richest \u200a\u2014\u200aComputes the richest millionaire. This takes no parameters (will only read from state) and returns the richest millionaire\u2019s address, which is of type H160 construct \u200a\u2014\u200aThis is actually not present in this secret contract, because the contract is not initialized with any data. Therefore, it is left it out entirely, meaning it defaults to the implicit construct() . Now add: ` // Implementation of the public-facing secret contract functions defined in the ContractInterface // trait implementation for the Contract struct above impl ContractInterface for Contract { #[no_mangle] fn add_millionaire(address: H160, net_worth: U256) { let mut millionaires = Self::get_millionaires(); millionaires.push(Millionaire { address, net_worth, }); write_state!(MILLIONAIRES = millionaires); } `` #[no_mangle] fn compute_richest() - H160 { match Self::get_millionaires().iter().max_by_key(|m| m.net_worth) { Some(millionaire) = { millionaire.address }, None = H160::zero(), } } } ` This section implements the above-defined public-facing secret contract methods. Note the #[no_mangle] annotation above every method definition, which turns off Rust\u2019s automatic method/function name-changing behavior. add_millionaire \u200a\u2014\u200aRead the secret contract state to obtain the list of Millionaire structs (using the private method get_millionaires mentioned above). Push a new Millionaire struct with the fields initialized to the parameters passed into this method ( address and net_worth ). And finally, update/write to the secret contract state with the macro: write_state!( key_1 = value_1 , key2 = value_2 , ..., key_n = value_n ) . compute_richest \u200a\u2014\u200aObtain the list of Millionaire structs stored in contract state. Using a combination of Rust's match and max_by_key functionalities, return the address associated with the millionaire with the highest net_worth , otherwise return the empty address 0x0 . construct \u2014As we do not need our own implementation of a secret contract constructor, this utilizes the default empty construct() definition, and thus it is left out. Next, check out our tutorial on compiling, migrating, and unit-testing this contract.","title":"Write a Secret Contract"},{"location":"Walkthrough_secretContract/#writing-a-secret-contract","text":"This walkthrough will take you through the process of initializing a project, creating a secret contract, and writing unit-tests for this contract.","title":"Writing a secret contract"},{"location":"Walkthrough_secretContract/#setting-up-project-structure","text":"Start the network with\u200a discovery start This should only take 15\u201320 seconds (unless it is your first time, in which case it may take 3\u20134 minutes). Create a brand new Rust library containing our secret contract logic with the following command: cargo new secret_contracts/millionaires_problem --lib Copy and paste the contents of the secret_contracts/Cargo.toml.template file into the Cargo.toml file inside the library of secret_contracts/millionaires_problem that was just created. Under [dependencies] add this line: serde = \u201c1.0.84\u201d . The full Cargo.toml file should now read: [package] name = \"contract\" version = \"0.1.0\" [dependencies] eng-wasm = { git = \"https://github.com/enigmampc/enigma-core.git\", branch = \"develop\" } eng-wasm-derive = { git = \"https://github.com/enigmampc/enigma-core.git\", branch = \"develop\" } serde = \"1.0.84\" [lib] crate-type = [\"cdylib\"] [profile.release] panic = \"abort\" lto = true opt-level = \"z\"","title":"Setting Up Project Structure"},{"location":"Walkthrough_secretContract/#writing-the-secret-contract","text":"Open the lib.rs file located at secret_contracts/millionaires_problem/src/lib.rs Delete existing file contents. Add the following code. ` // Built-In Attributes #![no_std] ` All of our secret contracts exactly like this, because the SGX environment does not support all the features of Rust's standard library. [This attribute](https://medium.com/r/?url=http%3A%2F%2Frust%20import) removes the standard library from our program\u2019s prelude accordingly. Now add: ``` // Imports extern crate eng_wasm; extern crate eng_wasm_derive; extern crate serde; `` use eng_wasm::*; use eng_wasm_derive::pub_interface; use serde::{Serialize, Deserialize}; ``` This brings the following packages into scope: eng_wasm \u200a\u2014\u200aThis crate allows us to use the Enigma runtime, offering important functionalities including reading from state, writing to state, and printing. eng_wasm_derive \u200a\u2014\u200aThis crate provides functions exposed by the contract that can be called from the Enigma network and the ability to call functions of Ethereum contracts from a secret contract. eng_wasm_derive::pub_interface \u200a\u2014\u200aGives us the ability to add the #[pub_interface] trait to any public-facing functions within our secret contract. serde::{Serialize, Deserialize} \u200a\u2014\u200aAllows us to serialize and deserialize custom struct types. Next add: // Encrypted state keys static MILLIONAIRES: str = \"millionaires\"; Secret contracts can maintain encrypted state. Our contract needs to maintain a list of millionaires in state, which must have an entry key, value pair that looks something like this: \"millionaires\", vector of Millionaire structs . As shown, \"millionaires\" is the key into this encrypted state maintaining the list of millionaires. Below the state keys, add: ~~~ // Structs #[derive(Serialize, Deserialize)] pub struct Millionaire { address: H160, net_worth: U256, } ~~~ A millionaire\u2019s metadata consists the following attributes: 1. ETH address 2. net_worth Note the variable types. address is of type H160 , which corresponds to a 160-bit/20-byte hash value (recall that ETH addresses are 20 bytes long) and net_worth is of type U256 , which corresponds to a 256-bit/32-byte value. (For those of you with Solidity backgrounds, you can think of these as address and uint256 types, respectively.) Now add: // Public struct Contract which will consist of private and public- facing secret contract functions pub struct Contract; This initializes a public struct called Contract which can consist of both private and public-facing functions to be defined later. Add: // Private functions accessible only by the secret contract impl Contract { fn get_millionaires() - Vec Millionaire { read_state!(MILLIONAIRES).unwrap_or_default() } } This code implements the private methods for the secret contract. get_millionaires() returns Vec Millionaire , a vector of Millionaire structs stored in state. Note how we read from secret contract state with the macro read_state!( key ) . The unwrap_or_default() method returns the contained value, otherwise the default for that type. Next, add: ` // Public trait defining public-facing secret contract functions #[pub_interface] pub trait ContractInterface{ fn add_millionaire(address: H160, net_worth: U256); fn compute_richest() - H160; } ` This section declares the public-facing secret contract signatures by creating a public trait with the #[pub_interface] macro. In this case, there is now a trait called ContractInterface and two method definitions: add_millionaire \u200a\u2014\u200aAdd/register a new millionaire with an Ethereum address ( H160 ) and net worth ( U256 ) compute_richest \u200a\u2014\u200aComputes the richest millionaire. This takes no parameters (will only read from state) and returns the richest millionaire\u2019s address, which is of type H160 construct \u200a\u2014\u200aThis is actually not present in this secret contract, because the contract is not initialized with any data. Therefore, it is left it out entirely, meaning it defaults to the implicit construct() . Now add: ` // Implementation of the public-facing secret contract functions defined in the ContractInterface // trait implementation for the Contract struct above impl ContractInterface for Contract { #[no_mangle] fn add_millionaire(address: H160, net_worth: U256) { let mut millionaires = Self::get_millionaires(); millionaires.push(Millionaire { address, net_worth, }); write_state!(MILLIONAIRES = millionaires); } `` #[no_mangle] fn compute_richest() - H160 { match Self::get_millionaires().iter().max_by_key(|m| m.net_worth) { Some(millionaire) = { millionaire.address }, None = H160::zero(), } } } ` This section implements the above-defined public-facing secret contract methods. Note the #[no_mangle] annotation above every method definition, which turns off Rust\u2019s automatic method/function name-changing behavior. add_millionaire \u200a\u2014\u200aRead the secret contract state to obtain the list of Millionaire structs (using the private method get_millionaires mentioned above). Push a new Millionaire struct with the fields initialized to the parameters passed into this method ( address and net_worth ). And finally, update/write to the secret contract state with the macro: write_state!( key_1 = value_1 , key2 = value_2 , ..., key_n = value_n ) . compute_richest \u200a\u2014\u200aObtain the list of Millionaire structs stored in contract state. Using a combination of Rust's match and max_by_key functionalities, return the address associated with the millionaire with the highest net_worth , otherwise return the empty address 0x0 . construct \u2014As we do not need our own implementation of a secret contract constructor, this utilizes the default empty construct() definition, and thus it is left out. Next, check out our tutorial on compiling, migrating, and unit-testing this contract.","title":"Writing the Secret Contract"},{"location":"WhyRust/","text":"Why Rust? \u2699\ufe0f Rust is an excellent programming language that simultaneously optimizes for both safety and performance in a way few languages can claim. The Rust core team has created a language that allows for veteran developers and newcomers alike to develop production-ready, systems-level code. Performance \ud83c\udfce\ufe0f Rust features a unique and powerful combination of the cargo package manager (overlooked in higher level languages), zero-cost abstractions , memory management that is both manual and smart in nature (thereby avoiding both the runtime garbage collection costs you find in Python and Ruby as well as the error-prone nature of manual management in C and C++), and many other features. Safety \ud83d\udc77 The strict compilation checks and error explanations Rust offers prevent large classes of common errors, supporting safe and performant code. Community \ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1 Last, but certainly not least, there is a wonderful community of Rustaceans (a weird, but endearing term that will grow on you over time) that will support whatever your journey may be. Joining this community puts you in good company\u200a\u2014\u200aas one recent survey shows, Rust has been voted the most loved programming language for the third year in a row!","title":"Why Rust? \u2699\ufe0f"},{"location":"WhyRust/#why-rust","text":"Rust is an excellent programming language that simultaneously optimizes for both safety and performance in a way few languages can claim. The Rust core team has created a language that allows for veteran developers and newcomers alike to develop production-ready, systems-level code.","title":"Why Rust? \u2699\ufe0f"},{"location":"WhyRust/#performance","text":"Rust features a unique and powerful combination of the cargo package manager (overlooked in higher level languages), zero-cost abstractions , memory management that is both manual and smart in nature (thereby avoiding both the runtime garbage collection costs you find in Python and Ruby as well as the error-prone nature of manual management in C and C++), and many other features.","title":"Performance \ud83c\udfce\ufe0f"},{"location":"WhyRust/#safety","text":"The strict compilation checks and error explanations Rust offers prevent large classes of common errors, supporting safe and performant code.","title":"Safety \ud83d\udc77"},{"location":"WhyRust/#community","text":"Last, but certainly not least, there is a wonderful community of Rustaceans (a weird, but endearing term that will grow on you over time) that will support whatever your journey may be. Joining this community puts you in good company\u200a\u2014\u200aas one recent survey shows, Rust has been voted the most loved programming language for the third year in a row!","title":"Community \ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1"},{"location":"types/","text":"Secret Contract Supported Types Signed integers: i32, i64 Unsigned integers: u32, u64 Unformatted binary data: H160, H256, H512 Unsigned big integers: U128, U256, U512 Vec String Bool Vec of any above-mentioned types Mapping of SC Types to Solidity Types i32 = int32 i64 = int64 u32 = uint32 u64 = uint64 H160 = address H256 = bytes32 U128 = uint128 U256 = uint256 Vec = bytes String = string Bool = bool","title":"Supported Types"},{"location":"types/#secret-contract-supported-types","text":"Signed integers: i32, i64 Unsigned integers: u32, u64 Unformatted binary data: H160, H256, H512 Unsigned big integers: U128, U256, U512 Vec String Bool Vec of any above-mentioned types","title":"Secret Contract Supported Types"},{"location":"types/#mapping-of-sc-types-to-solidity-types","text":"i32 = int32 i64 = int64 u32 = uint32 u64 = uint64 H160 = address H256 = bytes32 U128 = uint128 U256 = uint256 Vec = bytes String = string Bool = bool","title":"Mapping of SC Types to Solidity Types"}]}